# Clic Actualizador Tools - Agente de Ejecución
# Versión: 1.3

# --- Configuración Inicial y Funciones Helper ---
$global:taskFailed = $false
$agentDir = $PSScriptRoot
$sevenZipPath = Join-Path $agentDir "7za.exe"

# Función para enviar logs al servidor central
function Log-ToServer {
    param(
        [Parameter(Mandatory=$true)] [string]$action,
        [Parameter(Mandatory=$true)] [string]$status,
        [Parameter(Mandatory=$false)] [string]$message,
        [Parameter(Mandatory=$false)] [string]$versionId,
        [Parameter(Mandatory=$false)] [int]$taskId
    )
    
    try {
        $logPayload = @{
            pcId = $pcId;
            pcName = $pcName;
            action = $action;
            status = $status;
            message = $message;
            versionId = $versionId;
            taskId = $taskId
        }
        
        Invoke-RestMethod -Uri "$serverUrl/api/tasks/log" -Method Post -Body ($logPayload | ConvertTo-Json) -ContentType "application/json" -ErrorAction Stop
    } catch {
        Write-Host "FATAL: No se pudo enviar el log al servidor. Error: $($_.Exception.Message)"
    }
}

# --- Bucle Principal del Agente ---
while ($true) {
    try {
        # Cargar configuración desde el config.json en el mismo directorio
        $configPath = Join-Path $agentDir "config.json"
        if (-not (Test-Path $configPath)) {
            Write-Host "FATAL: config.json no encontrado en $agentDir. Saliendo."
            Start-Sleep -Seconds 60
            continue
        }
        $config = Get-Content $configPath | ConvertFrom-Json
        $serverUrl = $config.serverUrl
        $pcId = $env:COMPUTERNAME # O un identificador único si se prefiere
        $pcName = $env:COMPUTERNAME
        
        # Payload de chequeo de tareas
        $checkPayload = @{
            agentVersion = "1.3";
            pcName = $pcName
        }

        # Chequear si hay tareas pendientes
        $response = Invoke-RestMethod -Uri "$serverUrl/api/tasks/check/$pcId" -Method Post -Body ($checkPayload | ConvertTo-Json) -ContentType "application/json" -ErrorAction Stop
        
        # Si no hay tarea, esperar y continuar el bucle
        if ($response.task -eq "ninguna") {
            Start-Sleep -Seconds 30
            continue
        }

        # --- Procesamiento de Tarea ---
        $global:taskFailed = $false
        $taskConfig = $response.config
        $taskId = $response.taskId
        $servicesToRestart = @()

        Log-ToServer -action "Procesando tarea $($taskConfig.name)" -status "Éxito" -message "Tarea recibida por el agente." -taskId $taskId

        # Detener servicios si es necesario
        if (-not ([string]::IsNullOrEmpty($taskConfig.serviceName))) {
            $serviceNames = $taskConfig.serviceName.Split(',') | ForEach-Object { $_.Trim() }
            foreach ($service in $serviceNames) {
                try {
                    $serviceStatus = Get-Service -Name $service -ErrorAction Stop
                    if ($serviceStatus.Status -eq 'Running') {
                        Log-ToServer -action "Deteniendo servicio" -status "Éxito" -message "Deteniendo servicio: $service" -taskId $taskId
                        Stop-Service -Name $service -Force -ErrorAction Stop
                        $servicesToRestart += $service
                    }
                } catch {
                    # No tratar como error fatal si el servicio no existe
                    Log-ToServer -action "Deteniendo servicio" -status "Omitido" -message "El servicio $service no existe o no se pudo detener. Error: $($_.Exception.Message)" -taskId $taskId
                }
            }
        }
        
        # --- Lógica por Tipo de Paquete ---
        try {
            if ($taskConfig.packageType -eq "actualizacion_archivos") {
                if (-not (Test-Path $sevenZipPath)) {
                    throw "7za.exe no encontrado en $agentDir. La extracción de archivos no puede continuar."
                }
                Log-ToServer -action "Copiando archivos" -status "Éxito" -message "Iniciando descarga desde $($taskConfig.updateFilePath)" -taskId $taskId
                Copy-Item -Path $taskConfig.updateFilePath -Destination $taskConfig.localUpdateDir -Force -ErrorAction Stop
                
                $fileName = Split-Path $taskConfig.updateFilePath -Leaf
                $localArchiveFile = Join-Path $taskConfig.localUpdateDir $fileName

                Log-ToServer -action "Extrayendo archivos" -status "Éxito" -message "Extrayendo $fileName en $($taskConfig.installDir)" -taskId $taskId
                & $sevenZipPath x $localArchiveFile -o"$($taskConfig.installDir)" -y | Out-Null
            } 
            elseif ($taskConfig.packageType -eq "ejecutar_script") {
                Log-ToServer -action "Ejecutando script" -status "Éxito" -message "Descargando y ejecutando $($taskConfig.updateFilePath)" -taskId $taskId
                $scriptFileName = Split-Path $taskConfig.updateFilePath -Leaf
                $localScriptPath = Join-Path $env:TEMP $scriptFileName
                Copy-Item -Path $taskConfig.updateFilePath -Destination $localScriptPath -Force -ErrorAction Stop
                
                # Ejecutar el script
                & $localScriptPath
            }
            elseif ($taskConfig.packageType -eq "comando_powershell") {
                Log-ToServer -action "Ejecutando comando PS" -status "Éxito" -message "Ejecutando: $($taskConfig.command)" -taskId $taskId
                Invoke-Expression -Command $taskConfig.command
            }
            elseif ($taskConfig.packageType -eq "registro_componentes") {
                Log-ToServer -action "Registro de Componentes" -status "Éxito" -message "Iniciando registro desde $($taskConfig.updateFilePath)" -taskId $taskId
                
                # Determinar la ruta correcta de RegAsm.exe (32 vs 64 bits)
                $regAsmPath = ""
                if ($env:PROCESSOR_ARCHITECTURE -eq "AMD64") {
                    $regAsmPath = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe"
                } else {
                    $regAsmPath = "C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe"
                }

                [xml]$xml = Get-Content $taskConfig.updateFilePath
                $baseDir = $taskConfig.installDir

                foreach ($componente in $xml.COMPONENTES.COMPONENTE) {
                    $componentName = $componente.Nombre
                    $componentType = $componente.Tipo
                    
                    try {
                        $fileToRegister = ""
                        $action = ""

                        if ($componentType -eq "COMEXE") {
                            $fileToRegister = Join-Path $baseDir "$componentName.exe"
                            if (Test-Path $fileToRegister) {
                                Log-ToServer -action "Registrando COM EXE" -status "Éxito" -message "Registrando $componentName.exe" -taskId $taskId
                                Start-Process -FilePath "regsvr32.exe" -ArgumentList "/s `"$fileToRegister`"" -Wait
                            } else {
                                $fileToRegister = Join-Path $baseDir "$componentName.dll"
                                if (Test-Path $fileToRegister) {
                                     Log-ToServer -action "Registrando COM DLL" -status "Éxito" -message "Registrando $componentName.dll" -taskId $taskId
                                     Start-Process -FilePath "regsvr32.exe" -ArgumentList "/s `"$fileToRegister`"" -Wait
                                } else {
                                    throw "No se encontró $componentName.exe o $componentName.dll en $baseDir"
                                }
                            }
                        }
                        elseif ($componentType -like "ASSEMBLY*") {
                            $fileToRegister = Join-Path $baseDir "$componentName.dll"
                             if (Test-Path $fileToRegister) {
                                Log-ToServer -action "Registrando Assembly .NET" -status "Éxito" -message "Registrando $componentName.dll con RegAsm" -taskId $taskId
                                Start-Process -FilePath $regAsmPath -ArgumentList "`"$fileToRegister`" /codebase /tlb" -Wait
                             } else {
                                 throw "No se encontró $componentName.dll en $baseDir"
                             }
                        }
                    } catch {
                         Log-ToServer -action "Registro de Componente" -status "Fallo" -message "Error registrando $componentName: $($_.Exception.Message)" -taskId $taskId
                    }
                }
            }
        
            # Ejecutar script Post-Instalación si existe y la tarea principal no ha fallado
            if (-not ([string]::IsNullOrEmpty($taskConfig.postInstallScript)) -and -not $global:taskFailed) {
                Log-ToServer -action "Script Post-Instalación" -status "Éxito" -message "Ejecutando script post-instalación." -taskId $taskId
                try {
                    Set-Location -Path $taskConfig.installDir -ErrorAction Stop
                    Invoke-Expression -Command $taskConfig.postInstallScript -ErrorAction Stop
                } catch {
                    throw "El script post-instalación falló con el error: $($_.Exception.Message)"
                }
            }

        } catch {
            # Captura de errores del bloque de lógica de paquete
            $errorMessage = $_.Exception.Message
            Log-ToServer -action "Tarea Fallida" -status "Fallo" -message $errorMessage -taskId $taskId
            $global:taskFailed = $true
        } finally {
             # Reiniciar servicios si es necesario
            foreach ($service in $servicesToRestart) {
                try {
                    $serviceStatus = Get-Service -Name $service -ErrorAction Stop
                    if ($serviceStatus.Status -eq 'Stopped') {
                        Log-ToServer -action "Reiniciando servicio" -status "Éxito" -message "Reiniciando servicio: $service" -taskId $taskId
                        Start-Service -Name $service -ErrorAction Stop
                    } else {
                         Log-ToServer -action "Reiniciando servicio" -status "Omitido" -message "El servicio $service ya se encuentra en estado $($serviceStatus.Status)." -taskId $taskId
                    }
                } catch {
                    Log-ToServer -action "Reiniciando servicio" -status "Fallo" -message "No se pudo reiniciar el servicio $service. Error: $($_.Exception.Message)" -taskId $taskId
                }
            }

            # Log final de la tarea
            if (-not $global:taskFailed) {
                 Log-ToServer -action "Actualización completada" -status "Éxito" -message "La tarea se completó sin errores." -versionId ($taskConfig.name) -taskId $taskId
            } else {
                 Log-ToServer -action "Actualización completada" -status "Fallo" -message "La tarea finalizó con uno o más errores." -taskId $taskId
            }
        }
        
        # Pausa breve antes de buscar la siguiente tarea
        Start-Sleep -Seconds 5

    } catch {
        # Captura de errores del bucle principal (ej. fallo de red al chequear tareas)
        Write-Host "ERROR: No se pudo conectar al servidor o procesar la respuesta. Reintentando en 60 segundos. Error: $($_.Exception.Message)"
        Start-Sleep -Seconds 60
    }
}
