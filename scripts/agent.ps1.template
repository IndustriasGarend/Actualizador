# Clic Actualizador Tools - Agente de Cliente
# Version: 1.3
# Este script se ejecuta como un servicio de Windows.
# Se conecta al servidor central para verificar y ejecutar tareas de actualización.

$ErrorActionPreference = "Stop"

# --- Función de Logging ---
# Escribe logs en la consola y los envía al servidor central.
function Write-Log {
    param(
        [Parameter(Mandatory=$true)]
        [string]$Action,
        [Parameter(Mandatory=$true)]
        [ValidateSet("Éxito", "Fallo", "Omitido", "Cancelado")]
        [string]$Status,
        [string]$Message = "",
        [string]$VersionId = $null,
        [string]$TaskId = $null
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Status] [$Action] $Message"
    Write-Output $logEntry

    try {
        $hardwareInfo = $null
        if ($Action -eq "Reportando estado inicial") {
            try {
                $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem
                $cpuInfo = Get-CimInstance -ClassName Win32_Processor
                $memInfo = Get-CimInstance -ClassName Win32_ComputerSystem
                $diskInfo = Get-CimInstance -ClassName Win32_DiskDrive | Select-Object Model, @{Name="Size";Expression={[math]::Round($_.Size / 1GB)}}
                
                $hardwareInfo = @{
                    osName = $osInfo.Caption
                    osVersion = $osInfo.Version
                    cpuModel = $cpuInfo.Name
                    cpuCores = $cpuInfo.NumberOfCores
                    totalMemory = [math]::Round($memInfo.TotalPhysicalMemory / 1MB)
                    disks = ($diskInfo | ConvertTo-Json -Compress)
                }
            } catch {
                Write-Output "Advertencia: No se pudo obtener la información de hardware."
            }
        }

        $body = @{
            pcId = $pcId
            pcName = $env:COMPUTERNAME
            agentVersion = $agentVersion
            ip = (Get-NetIPAddress -AddressFamily IPv4 -ErrorAction SilentlyContinue | Where-Object { $_.IPAddress -notlike "127.*" } | Select-Object -First 1).IPAddress
            loggedUser = (Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty UserName)
            action = $Action
            status = $Status
            message = $Message
            versionId = $VersionId
            taskId = $TaskId
            hardwareInfo = $hardwareInfo
        } | ConvertTo-Json -Depth 5

        Invoke-RestMethod -Uri "$serverUrl/api/tasks/log" -Method Post -Body $body -ContentType "application/json" -TimeoutSec 30
    } catch {
        Write-Output "ERROR: No se pudo enviar el log al servidor. $($_.Exception.Message)"
    }
}

# --- Funciones de Tareas ---

function Handle-Update-Files {
    param([PSCustomObject]$config)

    $services = $config.serviceName -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ }

    # 1. Detener servicios
    foreach ($service in $services) {
        try {
            $s = Get-Service -Name $service -ErrorAction Stop
            if ($s.Status -ne 'Stopped') {
                Write-Log "Actualización de Archivos" "Éxito" "Deteniendo servicio: $service..." $config.id
                Stop-Service -Name $service -Force
                Start-Sleep -Seconds 5
            }
        } catch {
            Write-Log "Actualización de Archivos" "Omitido" "No se pudo detener el servicio '$service' (puede que no exista o ya esté detenido)." $config.id
        }
    }

    # 2. Limpiar directorio temporal
    if (Test-Path $config.localUpdateDir) {
        Write-Log "Actualización de Archivos" "Éxito" "Limpiando directorio temporal: $($config.localUpdateDir)..." $config.id
        Remove-Item -Path $config.localUpdateDir -Recurse -Force
    }
    New-Item -Path $config.localUpdateDir -ItemType Directory -Force | Out-Null

    # 3. Descargar y extraer
    Write-Log "Actualización de Archivos" "Éxito" "Descargando desde $($config.updateFilePath)..." $config.id
    Copy-Item -Path $config.updateFilePath -Destination $config.localUpdateDir
    $compressedFile = Get-ChildItem -Path $config.localUpdateDir | Select-Object -First 1
    
    Write-Log "Actualización de Archivos" "Éxito" "Extrayendo $($compressedFile.Name)..." $config.id
    & "$PSScriptRoot\7za.exe" x "$($compressedFile.FullName)" "-o$($config.localUpdateDir)" -y | Out-Null

    # 4. Copiar archivos a producción
    Write-Log "Actualización de Archivos" "Éxito" "Copiando archivos a $($config.installDir)..." $config.id
    $extractedItems = Get-ChildItem -Path $config.localUpdateDir | Where-Object { $_.Name -ne $compressedFile.Name -and $_.Name -ne '7za.exe' }
    foreach ($item in $extractedItems) {
        Copy-Item -Path $item.FullName -Destination $config.installDir -Recurse -Force
    }

    # 5. Modificar PATH si es necesario
    if ($config.environmentPath) {
        Write-Log "Actualización de Archivos" "Éxito" "Verificando variable de entorno PATH..." $config.id
        $currentPath = [System.Environment]::GetEnvironmentVariable("Path", "Machine")
        $pathsToAdd = $config.environmentPath -split ';' | ForEach-Object { $_.Trim() } | Where-Object { $_ -and $currentPath -notlike "*$($_)*" }
        if ($pathsToAdd) {
            $newPath = ($currentPath.Split(';') + $pathsToAdd) | Where-Object { $_ } | Select-Object -Unique
            $newPathString = $newPath -join ';'
            [System.Environment]::SetEnvironmentVariable("Path", $newPathString, "Machine")
            Write-Log "Actualización de Archivos" "Éxito" "Variable PATH actualizada." $config.id
        }
    }

    # 6. Reiniciar servicios
    foreach ($service in $services) {
        try {
            Write-Log "Actualización de Archivos" "Éxito" "Iniciando servicio: $service..." $config.id
            Start-Service -Name $service
        } catch {
            Write-Log "Actualización de Archivos" "Omitido" "No se pudo iniciar el servicio '$service'." $config.id
        }
    }
}

function Handle-Execute-Script {
    param([PSCustomObject]$config)
    $localScriptPath = Join-Path -Path $PSScriptRoot -ChildPath "temp_script.ps1"
    
    Write-Log "Ejecutar Script" "Éxito" "Descargando script desde $($config.updateFilePath)..." $config.id
    Copy-Item -Path $config.updateFilePath -Destination $localScriptPath -Force

    Write-Log "Ejecutar Script" "Éxito" "Ejecutando script: $localScriptPath..." $config.id
    & $localScriptPath
}

function Handle-Execute-Command {
    param([PSCustomObject]$config)
    Write-Log "Comando PowerShell" "Éxito" "Ejecutando comando: $($config.command)..." $config.id
    Invoke-Expression -Command $config.command
}

function Handle-Register-Components {
    param([PSCustomObject]$config)
    $localXmlPath = Join-Path -Path $PSScriptRoot -ChildPath "reg_config.xml"
    
    Write-Log "Registro de Componentes" "Éxito" "Descargando archivo de registro desde $($config.updateFilePath)..." $config.id
    Copy-Item -Path $config.updateFilePath -Destination $localXmlPath -Force
    
    [xml]$xmlContent = Get-Content -Path $localXmlPath
    $components = $xmlContent.COMPONENTES.COMPONENTE

    # Buscar RegAsm.exe
    $regAsmPath = Get-ChildItem -Path "C:\Windows\Microsoft.NET\Framework" -Filter "RegAsm.exe" -Recurse -ErrorAction SilentlyContinue | Select-Object -Last 1 -ExpandProperty FullName
    
    foreach($component in $components) {
        $compName = $component.Nombre
        try {
            switch ($component.Tipo) {
                "COMEXE" { 
                    $exePath = Join-Path -Path $config.installDir -ChildPath "$compName.exe"
                    Write-Log "Registro de Componentes" "Éxito" "Registrando (COMEXE): $compName..." $config.id
                    & $exePath /regserver
                }
                "REGSVR32" {
                    $dllPath = Join-Path -Path $config.installDir -ChildPath "$compName"
                    Write-Log "Registro de Componentes" "Éxito" "Registrando (REGSVR32): $compName..." $config.id
                    regsvr32.exe /s $dllPath
                }
                "ASSEMBLY", "ASSEMBLYv4" {
                    if (!$regAsmPath) { throw "No se encontró RegAsm.exe." }
                    $dllPath = Join-Path -Path $config.installDir -ChildPath "$compName"
                    Write-Log "Registro de Componentes" "Éxito" "Registrando (ASSEMBLY): $compName..." $config.id
                    & $regAsmPath $dllPath /codebase /tlb
                }
                default {
                    Write-Log "Registro de Componentes" "Omitido" "Tipo de componente '$($component.Tipo)' no soportado para '$compName'." $config.id
                }
            }
        } catch {
             Write-Log "Registro de Componentes" "Fallo" "Error al registrar '$compName': $($_.Exception.Message)" $config.id
        }
    }
}

function Handle-Post-Install-Script {
    param([string]$scriptContent, [string]$taskId)
    
    $localScriptPath = Join-Path -Path $PSScriptRoot -ChildPath "post_install_script.ps1"
    Set-Content -Path $localScriptPath -Value $scriptContent
    
    Write-Log "Post-Instalación" "Éxito" "Ejecutando script de post-instalación..." $taskId
    & $localScriptPath
}

# --- Bucle Principal ---

# 1. Cargar configuración
$agentVersion = "1.3"
$configFile = "$PSScriptRoot\config.json"
if (-not (Test-Path $configFile)) {
    Write-Output "ERROR: Archivo de configuración '$configFile' no encontrado."
    exit 1
}
$config = Get-Content $configFile | ConvertFrom-Json
$serverUrl = $config.serverUrl
$pcId = (Get-CimInstance -Class Win32_ComputerSystemProduct).UUID

Write-Output "--- Clic Actualizador Tools Agent v$agentVersion ---"
Write-Output "Servidor: $serverUrl"
Write-Output "PC ID: $pcId"

# 2. Bucle infinito para verificar tareas
while ($true) {
    try {
        # Reportar estado inicial en el primer ciclo
        Write-Log "Reportando estado inicial" "Éxito"

        # Verificar si hay una tarea nueva
        $body = @{ agentVersion = $agentVersion; pcName = $env:COMPUTERNAME } | ConvertTo-Json
        $response = Invoke-RestMethod -Uri "$serverUrl/api/tasks/check/$pcId" -Method Post -Body $body -ContentType "application/json" -TimeoutSec 60
        
        $currentTask = $null
        $currentTaskId = $null

        if ($response.task -eq "actualizar") {
            $currentTask = $response.config.packageType
            $currentTaskId = $response.taskId

            Write-Log "Tarea Recibida" "Éxito" "Iniciando tarea '$currentTask' (ID: $currentTaskId)." $currentTaskId

            $taskConfig = $response.config | Select-Object *

            switch ($currentTask) {
                "actualizacion_archivos" { Handle-Update-Files -config $taskConfig }
                "ejecutar_script"        { Handle-Execute-Script -config $taskConfig }
                "comando_powershell"     { Handle-Execute-Command -config $taskConfig }
                "registro_componentes"   { Handle-Register-Components -config $taskConfig }
                default { throw "Tipo de paquete desconocido: $currentTask" }
            }

            # Ejecutar script post-instalación si existe
            if ($taskConfig.postInstallScript) {
                 Handle-Post-Install-Script -scriptContent $taskConfig.postInstallScript -taskId $currentTaskId
            }
            
            $versionId = if ($currentTask -eq "actualizacion_archivos") { Split-Path $taskConfig.updateFilePath -Leaf } else { $null }
            Write-Log "Actualización completada" "Éxito" "La tarea se completó correctamente." $versionId $currentTaskId

        } elseif ($response.task -eq "actualizar_agente") {
            Write-Log "Auto-Actualización" "Fallo" "El agente está desactualizado. La auto-actualización aún no está implementada."
            # Lógica futura para descargar y ejecutar el nuevo instalador
        
        } elseif ($response.task -eq "cancelar") {
             Write-Log "Tarea Cancelada" "Cancelado" "La tarea $($response.taskId) fue cancelada por el servidor." $null $response.taskId
        
        }

    } catch {
        $errorMessage = $_.Exception.Message
        if ($_.Exception.Response) {
            $errorMessage += " Contenido: " + ($_.Exception.Response.Content | Out-String)
        }
        Write-Log "Error en Agente" "Fallo" $errorMessage $null $currentTaskId
    }
    
    # Esperar antes de la próxima verificación (ej. 1 minuto)
    Start-Sleep -Seconds 60
}
