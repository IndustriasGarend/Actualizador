# Versión: 1.3
# Agente de Clic Actualizador Tools

# --- Configuración de Errores y Entorno ---
$ErrorActionPreference = "Stop"
$global:taskFailed = $false

# --- Funciones de Logging ---
function Log-Message {
    param (
        [string]$action,
        [string]$status,
        [string]$message = "",
        [string]$versionId = $null,
        [string]$taskId = $null
    )
    
    $pcId = Get-WmiObject Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID
    $pcName = $env:COMPUTERNAME
    $agentVersion = "1.3"
    $ip = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias (Get-NetConnectionProfile).InterfaceAlias).IPAddress
    try {
        $loggedUser = (Get-WmiObject -ClassName Win32_ComputerSystem).UserName
    } catch {
        $loggedUser = "No disponible"
    }

    $body = @{
        pcId = $pcId
        pcName = $pcName
        action = $action
        status = $status
        message = $message
        versionId = $versionId
        taskId = $taskId
        agentVersion = $agentVersion
        ip = $ip
        loggedUser = $loggedUser
    }

    # Solo recolectar info de hardware la primera vez o cada cierto tiempo para no sobrecargar
    if ($action -eq "Heartbeat") {
         try {
            $os = Get-WmiObject -Class Win32_OperatingSystem
            $cpu = Get-WmiObject -Class Win32_Processor
            $memory = Get-WmiObject -Class Win32_ComputerSystem
            $disks = Get-WmiObject -Class Win32_DiskDrive | Select-Object Model, @{Name="Size";Expression={[math]::Round($_.Size / 1GB)}}
            
            $body.hardwareInfo = @{
                osName = $os.Caption
                osVersion = $os.Version
                cpuModel = $cpu.Name
                cpuCores = $cpu.NumberOfCores
                totalMemory = [math]::Round($memory.TotalPhysicalMemory / 1MB)
                disks = ($disks | ConvertTo-Json -Compress)
            }
        } catch {
            # No hacer nada si falla la recolección de hardware
        }
    }

    $jsonBody = $body | ConvertTo-Json -Depth 5
    
    try {
        Invoke-RestMethod -Uri "$serverUrl/api/tasks/log" -Method Post -Body $jsonBody -ContentType "application/json; charset=utf-8"
    } catch {
        Write-Host "FATAL: No se pudo comunicar con el servidor en $serverUrl. Verifique la conexión y la configuración."
    }
}

# --- Bucle Principal del Agente ---
while ($true) {
    try {
        # --- Obtener configuración del servidor ---
        $configPath = Join-Path $PSScriptRoot "config.json"
        if (-not (Test-Path $configPath)) {
            Write-Host "FATAL: No se encontró config.json. El agente no puede iniciar."
            Start-Sleep -Seconds 60
            continue
        }
        $configContent = Get-Content $configPath -Encoding UTF8 -Raw
        $serverUrl = ($configContent | ConvertFrom-Json).serverUrl
        $pcId = Get-WmiObject Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID
        $pcName = $env:COMPUTERNAME
        $agentVersion = "1.3"

        # Verificar 7za.exe
        $sevenZipPath = Join-Path $PSScriptRoot "7za.exe"
        if (-not (Test-Path $sevenZipPath)) {
            Log-Message -action "Error de Agente" -status "Fallo" -message "No se encontró 7za.exe. Las tareas de descompresión fallarán."
        }

        # --- Detección de arquitectura para RegAsm ---
        $regAsmPath = ""
        if ([System.Environment]::Is64BitOperatingSystem) {
            $regAsmPath = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe"
        } else {
            $regAsmPath = "C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe"
        }

        # --- Comprobar si hay tareas pendientes ---
        $checkBody = @{ agentVersion = $agentVersion; pcName = $pcName } | ConvertTo-Json
        $taskResponse = Invoke-RestMethod -Uri "$serverUrl/api/tasks/check/$pcId" -Method Post -Body $checkBody -ContentType "application/json; charset=utf-f"
        
        $task = $taskResponse.task
        $taskId = $taskResponse.taskId
        $config = $taskResponse.config

        # --- Ejecución de Tareas ---
        if ($task -eq "actualizar") {
            Log-Message -action "Procesando tarea..." -status "Éxito" -message "Recibida nueva tarea del tipo $($config.packageType)." -taskId $taskId
            
            $global:taskFailed = $false
            $servicesToRestart = New-Object System.Collections.Generic.List[string]

            try {
                # --- LÓGICA DE ACTUALIZACIÓN ---
                switch ($config.packageType) {
                    "actualizacion_archivos" {
                        # Detener servicios
                        if (-not [string]::IsNullOrWhiteSpace($config.serviceName)) {
                            $serviceNames = $config.serviceName -split ',' | ForEach-Object { $_.Trim() }
                            foreach ($service in $serviceNames) {
                                try {
                                    $s = Get-Service -Name $service -ErrorAction SilentlyContinue
                                    if ($s -and $s.Status -eq 'Running') {
                                        Log-Message -action "Deteniendo servicio" -status "Éxito" -message "Deteniendo servicio: $service" -taskId $taskId
                                        Stop-Service -Name $service -Force
                                        $servicesToRestart.Add($service)
                                    }
                                } catch {
                                    Log-Message -action "Deteniendo servicio" -status "Fallo" -message "No se pudo detener el servicio: $service. Error: $($_.Exception.Message)" -taskId $taskId
                                }
                            }
                        }

                        # Crear directorio de destino si no existe
                        if (-not (Test-Path $config.installDir)) {
                            New-Item -Path $config.installDir -ItemType Directory -Force
                        }
                        
                        # Descargar y extraer
                        $tempFile = Join-Path $config.localUpdateDir ([System.IO.Path]::GetFileName($config.updateFilePath))
                        New-Item -Path $config.localUpdateDir -ItemType Directory -Force | Out-Null
                        Log-Message -action "Descargando archivo" -status "Éxito" -message "Desde $($config.updateFilePath)" -taskId $taskId
                        Copy-Item -Path $config.updateFilePath -Destination $tempFile -Force
                        
                        Log-Message -action "Extrayendo archivos" -status "Éxito" -message "Hacia $($config.installDir)" -taskId $taskId
                        & $sevenZipPath x $tempFile -o"$($config.installDir)" -y | Out-Null

                        # Limpiar archivo temporal
                        Remove-Item $tempFile -Force
                    }
                    "ejecutar_script" {
                        $scriptFileName = [System.IO.Path]::GetFileName($config.updateFilePath)
                        $localScriptPath = Join-Path $PSScriptRoot "temp_script.ps1"
                        Copy-Item -Path $config.updateFilePath -Destination $localScriptPath -Force
                        
                        Log-Message -action "Ejecutando script" -status "Éxito" -message "Ejecutando $scriptFileName" -taskId $taskId
                        & $localScriptPath
                        Remove-Item $localScriptPath -Force
                    }
                    "comando_powershell" {
                        Log-Message -action "Ejecutando comando PS" -status "Éxito" -message "Comando: $($config.command)" -taskId $taskId
                        Invoke-Expression $config.command
                    }
                    "registro_componentes" {
                        $xmlPath = Join-Path $PSScriptRoot "temp_reg.xml"
                        Copy-Item -Path $config.updateFilePath -Destination $xmlPath -Force
                        [xml]$regXml = Get-Content $xmlPath

                        Set-Location -Path $config.installDir

                        foreach ($componente in $regXml.COMPONENTES.COMPONENTE) {
                            $compName = $componente.Nombre
                            $compType = $componente.Tipo
                            
                            $fileName = ""
                            $extension = ""

                            if ($compType -eq "COMEXE") { $extension = ".exe" }
                            elseif ($compType -eq "ASSEMBLY" -or $compType -eq "ASSEMBLYv4" -or $compType -eq "REGSVR32") { $extension = ".dll" }

                            if($extension) {
                               $fileName = $compName + $extension
                               $fullPath = Join-Path $config.installDir $fileName
                            }
                           
                            if ($fileName -and (Test-Path $fullPath)) {
                                try {
                                    if ($compType -eq "COMEXE" -or $compType -eq "REGSVR32") {
                                        Log-Message -action "Registrando Componente" -status "Éxito" -message "regsvr32.exe /s $fileName" -taskId $taskId
                                        Start-Process regsvr32.exe -ArgumentList "/s `"$fullPath`"" -Wait
                                    } elseif ($compType -eq "ASSEMBLY" -or $compType -eq "ASSEMBLYv4") {
                                        Log-Message -action "Registrando Assembly .NET" -status "Éxito" -message "$($regAsmPath) $fileName" -taskId $taskId
                                        Start-Process $regAsmPath -ArgumentList "`"$fullPath`" /codebase /tlb" -Wait
                                    }
                                } catch {
                                    Log-Message -action "Registro de Componente" -status "Fallo" -message "Error al registrar $fileName: $($_.Exception.Message)" -taskId $taskId
                                }
                            } else {
                                Log-Message -action "Registro de Componente" -status "Omitido" -message "No se encontró el archivo $fileName para el componente $compName" -taskId $taskId
                            }
                        }
                        Remove-Item $xmlPath -Force
                    }
                }
                
                # --- EJECUTAR SCRIPT POST-INSTALACIÓN ---
                if (-not [string]::IsNullOrWhiteSpace($config.postInstallScript)) {
                    Log-Message -action "Script Post-Instalación" -status "Éxito" -message "Ejecutando script personalizado." -taskId $taskId
                    if(-not [string]::IsNullOrWhiteSpace($config.installDir) -and (Test-Path $config.installDir)) {
                        Set-Location -Path $config.installDir
                    }
                    Invoke-Expression $config.postInstallScript
                }

            } catch {
                $global:taskFailed = $true
                $errorMessage = "Error en la tarea: $($_.Exception.Message)"
                Log-Message -action "Error en Tarea" -status "Fallo" -message $errorMessage -taskId $taskId
            } finally {
                # Reiniciar servicios detenidos solo si la tarea no falló en la parte principal
                if ($servicesToRestart.Count -gt 0) {
                    Log-Message -action "Reiniciando servicios" -status "Éxito" -message "Iniciando servicios detenidos..." -taskId $taskId
                    foreach ($service in $servicesToRestart) {
                        try {
                            $s = Get-Service -Name $service
                            if ($s.Status -eq 'Stopped') {
                                Start-Service -Name $service
                                Log-Message -action "Reiniciando servicio" -status "Éxito" -message "Servicio $service iniciado." -taskId $taskId
                            }
                        } catch {
                            Log-Message -action "Reiniciando servicio" -status "Fallo" -message "No se pudo reiniciar el servicio $service. Error: $($_.Exception.Message)" -taskId $taskId
                        }
                    }
                }
            }

            # --- Log Final de Tarea ---
            if ($global:taskFailed) {
                 Log-Message -action "Actualización fallida" -status "Fallo" -message "La tarea no se completó. Revise los logs anteriores." -versionId $config.name -taskId $taskId
            } else {
                 Log-Message -action "Actualización completada" -status "Éxito" -message "La tarea se ha completado correctamente." -versionId $config.name -taskId $taskId
            }
        
        } elseif ($task -eq "cancelar") {
            Log-Message -action "Tarea Cancelada" -status "Cancelado" -message "La tarea fue cancelada desde el servidor." -taskId $taskId

        } elseif ($task -eq "actualizar_agente") {
            # Lógica para auto-actualizar el agente (a implementar)
            Log-Message -action "Agente Desactualizado" -status "Omitido" -message "El agente necesita actualizarse (v$agentVersion). La auto-actualización aún no está implementada."

        } else {
            # Heartbeat
            Log-Message -action "Heartbeat" -status "Éxito"
        }
        
    } catch {
        # Error en el bucle principal (ej. fallo de red al llamar a /check)
        $errorMessage = "Error en el agente: $($_.Exception.Message)"
        Log-Message -action "Error de Agente" -status "Fallo" -message $errorMessage
    }

    # Esperar antes de la siguiente verificación
    Start-Sleep -Seconds 30
}
