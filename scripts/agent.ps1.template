# --- Softland Updater Agent ---
# Version: 1.1

# --- Configuracion (se reemplaza durante la generacion) ---
$ServerUrl = "__SERVER_URL__"
$PCId = "__PC_ID__"
$AgentVersion = "1.1"

# --- Variables Globales ---
$SevenZipPath = Join-Path $PSScriptRoot "7za.exe"

# --- Funciones ---
function Get-HardwareInfo {
    $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem
    $cpuInfo = Get-CimInstance -ClassName Win32_Processor
    $memoryInfo = Get-CimInstance -ClassName Win32_ComputerSystem
    $diskInfo = Get-CimInstance -ClassName Win32_DiskDrive | Where-Object { $_.MediaType -like 'Fixed*' -or $_.MediaType -like 'SSD*'}

    $disks = $diskInfo | ForEach-Object {
        @{
            model = $_.Model
            size = [math]::Round($_.Size / 1GB)
        }
    }

    return @{
        osName = $osInfo.Caption
        osVersion = $osInfo.Version
        cpuModel = $cpuInfo.Name
        cpuCores = $cpuInfo.NumberOfLogicalProcessors
        totalMemory = [math]::Round($memoryInfo.TotalPhysicalMemory / 1MB)
        disks = $disks | ConvertTo-Json -Compress
    }
}

function Get-CurrentUserInfo {
    try {
        $user = (Get-WmiObject -Class Win32_ComputerSystem).Username
        return $user
    } catch {
        return $null
    }
}

function Send-Log {
    param(
        [string]$Action,
        [string]$Status,
        [string]$Message,
        [string]$VersionId = $null,
        [int]$TaskId = $null,
        [boolean]$SendHardwareInfo = $false
    )
    
    $pcName = $env:COMPUTERNAME
    $ipAddress = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias (Get-NetConnectionProfile).InterfaceAlias).IPAddress
    
    $body = @{
        pcId = $PCId
        pcName = $pcName
        action = $Action
        status = $Status
        message = $Message
        versionId = $VersionId
        taskId = $TaskId
        agentVersion = $AgentVersion
        ip = $ipAddress
        loggedUser = Get-CurrentUserInfo
    }

    if ($SendHardwareInfo) {
        $body.Add("hardwareInfo", (Get-HardwareInfo))
    }

    try {
        Invoke-RestMethod -Uri "$ServerUrl/api/tasks/log" -Method Post -Body ($body | ConvertTo-Json) -ContentType "application/json"
        Write-Host "Log enviado: $Action - $Status"
    } catch {
        Write-Host "Error al enviar log: $($_.Exception.Message)"
    }
}

function Register-SoftlandComponents {
    param(
        [string]$InstallPath,
        [int]$TaskId
    )
    $regFile = Join-Path $InstallPath "ERPReg.xml"
    if (-not (Test-Path $regFile)) {
        Send-Log -Action "Registro de Componentes" -Status "Omitido" -Message "No se encontro ERPReg.xml." -TaskId $TaskId
        return
    }

    try {
        [xml]$xml = Get-Content -Path $regFile
        $components = $xml.COMPONENTES.COMPONENTE
        
        $regAsmPath = Join-Path ([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory()) "RegAsm.exe"
        $regAsmPathV4 = Join-Path "C:\Windows\Microsoft.NET\Framework\v4.0.30319" "RegAsm.exe"

        foreach ($component in $components) {
            $componentName = $component.Nombre
            $componentType = $component.Tipo
            $componentPath = Join-Path $InstallPath $componentName
            
            if(-not (Test-Path $componentPath)){
                Send-Log -Action "Registro de Componentes" -Status "Fallo" -Message "No se encontro el archivo '$componentName' para registrar." -TaskId $TaskId
                continue
            }

            try {
                switch ($componentType) {
                    "REGSVR32" {
                        Start-Process "regsvr32.exe" -ArgumentList "/s `"$componentPath`"" -Wait
                    }
                    "ASSEMBLY" {
                         Start-Process $regAsmPath -ArgumentList "/silent /codebase `"$componentPath`"" -Wait
                    }
                    "ASSEMBLYv4" {
                         Start-Process $regAsmPathV4 -ArgumentList "/silent /codebase `"$componentPath`"" -Wait
                    }
                }
                 Send-Log -Action "Registro de Componentes" -Status "Exito" -Message "Componente '$componentName' registrado." -TaskId $TaskId
            } catch {
                Send-Log -Action "Registro de Componentes" -Status "Fallo" -Message "Error registrando '$componentName': $($_.Exception.Message)" -TaskId $TaskId
            }
        }
    } catch {
         Send-Log -Action "Registro de Componentes" -Status "Fallo" -Message "Error procesando ERPReg.xml: $($_.Exception.Message)" -TaskId $TaskId
    }
}

# --- Ciclo Principal ---
while ($true) {
    try {
        # 1. Enviar telemetria y verificar tareas
        Send-Log -Action "Verificacion" -Status "Exito" -Message "Agente activo, verificando tareas." -SendHardwareInfo $true
        
        $response = Invoke-RestMethod -Uri "$ServerUrl/api/tasks/check/$PCId" -Method Post -Body (@{agentVersion = $AgentVersion} | ConvertTo-Json) -ContentType "application/json"
        
        # 2. Ejecutar tarea recibida
        switch ($response.task) {
            "actualizar_agente" {
                Send-Log -Action "Auto-Actualizacion Agente" -Status "Exito" -Message "Iniciando descarga de nueva version del agente."
                $updatePackagePath = Join-Path $PSScriptRoot "softland-agent-update.zip"
                Invoke-WebRequest -Uri "$ServerUrl/api/download-agent?forUpdate=true" -OutFile $updatePackagePath
                Expand-Archive -Path $updatePackagePath -DestinationPath $PSScriptRoot -Force
                # El nuevo install.bat se encargara de reemplazar y reiniciar el servicio
                Start-Process -FilePath (Join-Path $PSScriptRoot "install.bat")
                # Detener el agente actual
                exit
            }
            "cancelar" {
                Send-Log -Action "Cancelacion" -Status "Exito" -Message "Tarea de actualizacion cancelada desde el panel." -TaskId $response.taskId
            }
            "actualizar" {
                $config = $response.config
                $taskId = $response.taskId

                Send-Log -Action "Inicio de actualizacion" -Status "Exito" -Message "Iniciando proceso de actualizacion." -TaskId $taskId
                
                # --- Paso 1: Verificar version actual (ejemplo, se podria mejorar)
                $versionFile = Join-Path $config.softlandInstallDir "version.txt"
                $currentVersion = if (Test-Path $versionFile) { Get-Content $versionFile } else { "desconocida" }
                $updateFilename = [System.IO.Path]::GetFileName($config.updateFilePath)
                if ($currentVersion -eq $updateFilename) {
                    Send-Log -Action "Version ya actualizada" -Status "Omitido" -Message "La version actual ya es la mas reciente." -VersionId $updateFilename -TaskId $taskId
                    continue
                }

                # --- Paso 2: Detener servicios
                $serviceNames = $config.serviceName -split ',' | ForEach-Object { $_.Trim() }
                foreach ($service in $serviceNames) {
                    if (Get-Service $service -ErrorAction SilentlyContinue) {
                        Send-Log -Action "Deteniendo servicio" -Status "Exito" -Message "Deteniendo servicio '$service'..." -TaskId $taskId
                        Stop-Service -Name $service -Force
                    }
                }

                # --- Paso 3: Limpiar y copiar archivos
                $localUpdateDir = $config.localUpdateDir
                if (Test-Path $localUpdateDir) {
                    Remove-Item -Path $localUpdateDir -Recurse -Force
                }
                New-Item -Path $localUpdateDir -ItemType Directory
                Send-Log -Action "Copiando archivos" -Status "Exito" -Message "Copiando desde $($config.updateFilePath)..." -TaskId $taskId
                Copy-Item -Path $config.updateFilePath -Destination $localUpdateDir

                # --- Paso 4: Extraer archivos
                $archivePath = Join-Path $localUpdateDir $updateFilename
                $destPath = $config.softlandInstallDir
                Send-Log -Action "Extrayendo archivos" -Status "Exito" -Message "Extrayendo a '$destPath'..." -TaskId $taskId
                Start-Process $SevenZipPath -ArgumentList "x `"$archivePath`" -o`"$destPath`" -y" -Wait -NoNewWindow

                # --- Paso 5: Desbloquear archivos
                Send-Log -Action "Desbloqueando archivos" -Status "Exito" -Message "Desbloqueando archivos en '$destPath'..." -TaskId $taskId
                Get-ChildItem -Path $destPath -Recurse | Unblock-File

                # --- Paso 6: Configurar nuevos componentes
                Send-Log -Action "Configurando componentes" -Status "Exito" -Message "Procesando registro de modulos desde ERPReg.xml..." -TaskId $taskId
                Register-SoftlandComponents -InstallPath $destPath -TaskId $taskId
                
                # --- Paso 7: Configurar variable de entorno
                if ($config.environmentPath) {
                    Send-Log -Action "Configurando PATH" -Status "Exito" -Message "Anadiendo rutas al PATH del sistema." -TaskId $taskId
                    $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
                    $pathsToAdd = $config.environmentPath -split ';' | ForEach-Object { $_.Trim() }
                    $newPath = $currentPath
                    foreach($p in $pathsToAdd) {
                        if($currentPath -notlike "*$p*") {
                            $newPath += ";$p"
                        }
                    }
                    [Environment]::SetEnvironmentVariable("Path", $newPath, "Machine")
                }

                # --- Paso Final: Reportar exito
                Send-Log -Action "Actualizacion completada" -Status "Exito" -Message "Todos los modulos actualizados." -VersionId $updateFilename -TaskId $taskId
                Write-Host "Actualizacion completada."
            }
            "ninguna" {
                # No hay tareas, no hacer nada
            }
        }
    } catch {
        # Log de error general
        Send-Log -Action "Error en Agente" -Status "Fallo" -Message "Error inesperado en el ciclo principal: $($_.Exception.Message)"
    }
    
    # Esperar antes de la proxima verificacion
    Start-Sleep -Seconds 60
}
