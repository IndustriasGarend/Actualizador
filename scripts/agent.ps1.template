# Clic Actualizador Tools - Agente de Ejecución
# Version 1.3

# --- Configuración Inicial y Logging ---
$global:scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Definition
$global:logFile = Join-Path -Path $global:scriptDir -ChildPath "agent.log"
$global:taskFailed = $false

function Write-Log {
    param([string]$Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logMessage = "[$timestamp] - $Message"
    Add-Content -Path $global:logFile -Value $logMessage
    # Opcional: Mostrar en consola si se ejecuta interactivamente
    # Write-Host $logMessage
}

function Report-To-Server {
    param (
        [string]$action,
        [string]$status,
        [string]$message = "",
        [string]$versionId = "",
        [int]$taskId = 0,
        [PSCustomObject]$hardwareInfo = $null
    )
    try {
        $payload = @{
            pcId = $env:COMPUTERNAME
            pcName = $env:COMPUTERNAME
            action = $action
            status = $status
            message = $message
            versionId = $versionId
            taskId = $taskId
            agentVersion = "1.3"
            ip = (Get-NetIPAddress -AddressFamily IPv4 -ErrorAction SilentlyContinue | Where-Object { $_.PrefixOrigin -ne 'WellKnown' } | Select-Object -First 1).IPAddress
            loggedUser = (Get-CimInstance -ClassName Win32_ComputerSystem).UserName
        }

        if ($null -ne $hardwareInfo) {
            $payload.Add("hardwareInfo", $hardwareInfo)
        }

        $jsonPayload = $payload | ConvertTo-Json -Depth 5
        Invoke-RestMethod -Uri "$($global:serverUrl)/api/tasks/log" -Method Post -Body $jsonPayload -ContentType "application/json" -ErrorAction Stop
    } catch {
        Write-Log "FATAL: No se pudo reportar al servidor. Error: $($_.Exception.Message)"
    }
}

function Get-HardwareInfo {
    $os = Get-CimInstance -ClassName Win32_OperatingSystem
    $cpu = Get-CimInstance -ClassName Win32_Processor
    $memory = Get-CimInstance -ClassName Win32_ComputerSystem
    $disks = Get-CimInstance -ClassName Win32_DiskDrive | Select-Object @{N="size";E={[math]::Round($_.Size / 1GB)}}, model

    return [PSCustomObject]@{
        osName = $os.Caption
        osVersion = $os.Version
        cpuModel = $cpu.Name
        cpuCores = $cpu.NumberOfCores
        totalMemory = [math]::Round($memory.TotalPhysicalMemory / 1MB)
        disks = ($disks | ConvertTo-Json -Compress)
    }
}


# --- Función Principal de Tareas ---
function Execute-Task {
    param ($config, $taskId)

    Write-Log "Iniciando tarea ID $taskId con configuración..."
    Report-To-Server -action "Procesando tarea" -status "Éxito" -message "Tarea ID $taskId iniciada." -taskId $taskId

    $servicesToRestart = @()

    try {
        # 1. Detener servicios (si aplica)
        if (-not [string]::IsNullOrEmpty($config.serviceName)) {
            $serviceNames = $config.serviceName -split ',' | ForEach-Object { $_.Trim() }
            foreach ($service in $serviceNames) {
                $serviceObj = Get-Service -Name $service -ErrorAction SilentlyContinue
                if ($serviceObj -and $serviceObj.Status -eq 'Running') {
                    Write-Log "Deteniendo servicio: $service..."
                    Stop-Service -Name $service -Force
                    $servicesToRestart += $service # Recordar para reiniciar
                }
            }
        }
        
        $sevenZipPath = Join-Path -Path $global:scriptDir -ChildPath "7za.exe"
        if (-not (Test-Path $sevenZipPath)) {
            throw "CRITICO: No se encontró 7za.exe en el directorio del agente. No se pueden procesar archivos comprimidos."
        }

        # 2. Lógica principal basada en el tipo de paquete
        switch ($config.packageType) {
            "actualizacion_archivos" {
                Write-Log "Tipo de tarea: Actualización de Archivos."
                
                # Crear directorio local si no existe
                if (-not (Test-Path $config.localUpdateDir)) {
                    New-Item -Path $config.localUpdateDir -ItemType Directory | Out-Null
                }

                $fileName = Split-Path -Path $config.updateFilePath -Leaf
                $localFilePath = Join-Path -Path $config.localUpdateDir -ChildPath $fileName
                
                Write-Log "Copiando $($config.updateFilePath) a $($localFilePath)..."
                Copy-Item -Path $config.updateFilePath -Destination $localFilePath -Force

                Write-Log "Extrayendo $($localFilePath) a $($config.installDir)..."
                & $sevenZipPath x $localFilePath -o"$($config.installDir)" -y | Out-Null
            }
            "ejecutar_script" {
                Write-Log "Tipo de tarea: Ejecutar Script."
                $fileName = Split-Path -Path $config.updateFilePath -Leaf
                $localScriptPath = Join-Path -Path $global:scriptDir -ChildPath $fileName

                Write-Log "Descargando script $($config.updateFilePath) a $($localScriptPath)..."
                Copy-Item -Path $config.updateFilePath -Destination $localScriptPath -Force

                Write-Log "Ejecutando script: $localScriptPath..."
                & $localScriptPath
            }
            "comando_powershell" {
                Write-Log "Tipo de tarea: Comando PowerShell."
                Write-Log "Ejecutando comando: $($config.command)"
                Invoke-Expression -Command $config.command
            }
            "registro_componentes" {
                Write-Log "Tipo de tarea: Registro de Componentes."
                [xml]$xml = Get-Content -Path $config.updateFilePath
                
                $regAsmPath = "C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe"
                if (Test-Path "C:\Windows\Microsoft.NET\Framework64") {
                    $regAsmPath = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe"
                    Write-Log "Sistema de 64-bit detectado. Usando RegAsm de 64-bit."
                }

                Set-Location -Path $config.installDir
                Write-Log "Directorio de trabajo cambiado a $($config.installDir)"

                foreach ($componente in $xml.COMPONENTES.COMPONENTE) {
                    $nombre = $componente.Nombre
                    try {
                        switch ($componente.Tipo) {
                            "COMEXE" {
                                Write-Log "Registrando COMEXE: $nombre.exe"
                                & regsvr32.exe /s "$($nombre).exe"
                            }
                            "ASSEMBLY" {
                                Write-Log "Registrando ASSEMBLY: $nombre"
                                & $regAsmPath "$($nombre)" /codebase /tlb
                            }
                             "ASSEMBLYv4" {
                                Write-Log "Registrando ASSEMBLYv4: $nombre"
                                & $regAsmPath "$($nombre)" /codebase /tlb
                            }
                            "REGSVR32" {
                                 Write-Log "Registrando REGSVR32: $nombre"
                                & regsvr32.exe /s "$($nombre)"
                            }
                        }
                        Report-To-Server -action "Registro componente" -status "Éxito" -message "$nombre registrado." -taskId $taskId
                    } catch {
                         Report-To-Server -action "Registro componente" -status "Fallo" -message "Error al registrar $nombre: $($_.Exception.Message)" -taskId $taskId
                    }
                }
            }
        }

        # 3. Ejecutar script Post-Instalación (si aplica)
        if (-not [string]::IsNullOrEmpty($config.postInstallScript)) {
            Write-Log "Ejecutando script post-instalación..."
            if (-not [string]::IsNullOrEmpty($config.installDir) -and (Test-Path $config.installDir)) {
                Set-Location -Path $config.installDir
                Write-Log "Directorio de trabajo para post-script cambiado a $($config.installDir)"
            }
            Invoke-Expression -Command $config.postInstallScript
        }

    } catch {
        $errorMessage = $_.Exception.Message
        Write-Log "ERROR en la tarea $taskId: $errorMessage"
        Report-To-Server -action "Fallo en la tarea" -status "Fallo" -message $errorMessage -taskId $taskId
        $global:taskFailed = $true
    } finally {
        # 4. Reiniciar servicios (si aplica), solo los que estaban corriendo
        if ($servicesToRestart.Count -gt 0) {
            Write-Log "Reiniciando servicios..."
            foreach ($service in $servicesToRestart) {
                try {
                    $serviceObj = Get-Service -Name $service -ErrorAction SilentlyContinue
                    if ($serviceObj -and $serviceObj.Status -eq 'Stopped') {
                         Write-Log "Iniciando servicio: $service..."
                         Start-Service -Name $service
                    } else {
                         Write-Log "Servicio $service ya no estaba detenido. Omitiendo reinicio."
                    }
                } catch {
                    Write-Log "No se pudo reiniciar el servicio $service. Error: $($_.Exception.Message)"
                }
            }
        }

        # 5. Reporte final
        if (-not $global:taskFailed) {
            $versionId = if ($config.packageType -eq 'actualizacion_archivos') { $config.name } else { '' }
            Report-To-Server -action "Actualización completada" -status "Éxito" -message "La tarea finalizó correctamente." -versionId $versionId -taskId $taskId
            Write-Log "Tarea $taskId completada con éxito."
        } else {
             Write-Log "Tarea $taskId finalizada con fallos."
        }
    }
}


# --- Bucle Principal del Agente ---
try {
    Write-Log "Iniciando Agente de Clic Actualizador Tools..."
    $configPath = Join-Path -Path $global:scriptDir -ChildPath "config.json"
    if (-not (Test-Path $configPath)) {
        throw "No se encontró el archivo config.json. El agente no puede iniciar."
    }
    $global:serverUrl = (Get-Content -Raw -Path $configPath | ConvertFrom-Json).serverUrl
    Write-Log "Servidor configurado en: $($global:serverUrl)"

    Report-To-Server -action "Agente iniciado" -status "Éxito" -message "El agente se ha iniciado/reportado." -hardwareInfo (Get-HardwareInfo)
    
    # Bucle infinito para verificar tareas
    while ($true) {
        try {
            $checkPayload = @{
                agentVersion = "1.3"
                pcName = $env:COMPUTERNAME
            } | ConvertTo-Json
            
            $response = Invoke-RestMethod -Uri "$($global:serverUrl)/api/tasks/check/$($env:COMPUTERNAME)" -Method Post -Body $checkPayload -ContentType "application/json" -ErrorAction Stop
            
            if ($response.task -eq "actualizar") {
                Write-Log "Nueva tarea recibida: $($response.config.name)"
                Execute-Task -config $response.config -taskId $response.taskId
                $global:taskFailed = $false # Resetear bandera para la proxima tarea
            } elseif ($response.task -eq "cancelar") {
                Report-To-Server -action "Tarea cancelada por servidor" -status "Cancelado" -message "La tarea ID $($response.taskId) fue cancelada remotamente." -taskId $response.taskId
            } elseif ($response.task -eq "actualizar_agente") {
                Report-To-Server -action "Auto-actualización iniciada" -status "Éxito" -message "Descargando nuevo instalador del agente."
                $installerPath = Join-Path -Path $global:scriptDir -ChildPath "agent-installer.zip"
                Invoke-WebRequest -Uri "$($global:serverUrl)/api/download-agent" -OutFile $installerPath
                # El nuevo instalador debe ser ejecutado manualmente o por otro proceso.
                Report-To-Server -action "Auto-actualización lista" -status "Éxito" -message "Nuevo instalador descargado en $($installerPath). Se requiere ejecución manual."
            }

        } catch {
            $errorMessage = $_.Exception.Message
            if ($_.Exception.Response) {
                $errorMessage = $_.Exception.Response.GetResponseStream() | ForEach-Object { (New-Object System.IO.StreamReader($_)).ReadToEnd() }
            }
             Write-Log "Error en el bucle principal: $errorMessage"
        }
        
        # Esperar 30 segundos antes de la siguiente verificación
        Start-Sleep -Seconds 30
    }

} catch {
    Write-Log "ERROR CRITICO DEL AGENTE: $($_.Exception.Message)"
    Report-To-Server -action "Fallo crítico del agente" -status "Fallo" -message $_.Exception.Message
}
