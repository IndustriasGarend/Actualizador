# Clic Actualizador Tools - Agente de Servicio
# Version: {{AGENT_VERSION}}

# --- Configuración Inicial ---
$global:scriptPath = $PSScriptRoot
$global:taskFailed = $false
$global:agentVersion = "{{AGENT_VERSION}}"

# --- Funciones de Logging ---
# Escribe en un archivo de log local para depuración
function Write-LocalLog {
    param([string]$Message)
    $logFile = "C:\Windows\Temp\ClicUpdaterAgent.log"
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Add-Content -Path $logFile -Value "$timestamp - $Message"
}

# Envía un log de estado al servidor central
function Send-Log {
    param(
        [string]$Action,
        [string]$Status,
        [string]$Message = "",
        [string]$VersionId = $null,
        [int]$TaskId = $null
    )
    try {
        $pcId = Get-PCID
        $pcName = $env:COMPUTERNAME
        
        $body = @{
            pcId = $pcId
            pcName = $pcName
            action = $Action
            status = $Status
            message = $Message
            versionId = $VersionId
            taskId = $TaskId
            agentVersion = $global:agentVersion
            ip = (Get-NetIPAddress -AddressFamily IPv4 -ErrorAction SilentlyContinue | Select-Object -First 1).IPAddress
            loggedUser = (Get-CimInstance -ClassName Win32_ComputerSystem).UserName
        }

        # Solo obtener info de hardware en el primer reporte o si la tarea fue exitosa
        if ($Action -eq "Agente iniciado" -or ($Status -eq "Éxito" -and $Action -eq "Actualización completada")) {
            $os = Get-CimInstance Win32_OperatingSystem
            $cpu = Get-CimInstance Win32_Processor
            $memory = Get-CimInstance Win32_ComputerSystem
            $disks = Get-CimInstance Win32_DiskDrive | Select-Object Model, @{Name="Size"; Expression={[math]::Round($_.Size / 1GB)}}
            
            $body.hardwareInfo = @{
                osName = $os.Caption
                osVersion = $os.Version
                cpuModel = $cpu.Name
                cpuCores = $cpu.NumberOfCores
                totalMemory = [math]::Round($memory.TotalPhysicalMemory / 1MB)
                disks = $disks | ConvertTo-Json -Compress
            }
        }

        Invoke-RestMethod -Uri "$($global:serverUrl)/api/tasks/log" -Method Post -Body ($body | ConvertTo-Json -Depth 5) -ContentType "application/json" -TimeoutSec 30
    } catch {
        Write-LocalLog "FATAL: No se pudo enviar el log al servidor. Error: $($_.Exception.Message)"
    }
}

# --- Funciones de Ayuda ---
# Obtiene el MachineGuid como identificador único de la PC
function Get-PCID {
    return (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Cryptography" -Name "MachineGuid").MachineGuid
}

# Detiene una lista de servicios
function Stop-Services {
    param([string]$serviceNames)
    if (-not [string]::IsNullOrWhiteSpace($serviceNames)) {
        $services = $serviceNames.Split(',') | ForEach-Object { $_.Trim() }
        foreach ($service in $services) {
            try {
                Send-Log -Action "Deteniendo servicio" -Status "Éxito" -Message "Intentando detener el servicio: $service"
                Get-Service -Name $service -ErrorAction Stop | Stop-Service -Force -ErrorAction Stop
                Send-Log -Action "Servicio detenido" -Status "Éxito" -Message "El servicio '$service' fue detenido."
            } catch {
                # No consideramos esto un fallo crítico, puede que el servicio no exista o ya esté detenido
                Send-Log -Action "Deteniendo servicio" -Status "Omitido" -Message "No se pudo detener el servicio '$service' (puede que no exista o ya esté detenido)."
            }
        }
    }
}

# Inicia una lista de servicios
function Start-Services {
    param([string]$serviceNames)
    if (-not [string]::IsNullOrWhiteSpace($serviceNames)) {
        $services = $serviceNames.Split(',') | ForEach-Object { $_.Trim() }
        foreach ($service in $services) {
            try {
                Send-Log -Action "Iniciando servicio" -Status "Éxito" -Message "Intentando iniciar el servicio: $service"
                Get-Service -Name $service -ErrorAction Stop | Start-Service -ErrorAction Stop
                Send-Log -Action "Servicio iniciado" -Status "Éxito" -Message "El servicio '$service' fue iniciado."
            } catch {
                Send-Log -Action "Iniciando servicio" -Status "Fallo" -Message "No se pudo iniciar el servicio '$service'. Por favor, inícielo manualmente."
                $global:taskFailed = $true
            }
        }
    }
}

# Descarga y extrae 7zip si no existe
function Ensure-7za {
    $7zaPath = Join-Path $global:scriptPath "7za.exe"
    if (-not (Test-Path $7zaPath)) {
        Send-Log -Action "Descargando herramientas" -Status "Éxito" -Message "Descargando 7-Zip..."
        $zipUrl = "https://www.7-zip.org/a/7z2405-extra.7z"
        $zipPath = Join-Path $global:scriptPath "7z-extra.7z"
        try {
            Invoke-WebRequest -Uri $zipUrl -OutFile $zipPath -TimeoutSec 120
            # Necesitamos una forma de extraer el .7z inicial. Usamos PowerShell.
            Add-Type -AssemblyName "System.IO.Compression.FileSystem"
            [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $global:scriptPath)
            
            # Ahora que tenemos 7z.dll, deberíamos poder usar el comando expand
            Expand-Archive -Path $zipPath -DestinationPath $global:scriptPath -Force
            # Movemos el 7za.exe a la raíz
            Move-Item -Path (Join-Path $global:scriptPath "x64\7za.exe") -Destination $7zaPath -Force
            Remove-Item $zipPath -Force
            Send-Log -Action "Descargando herramientas" -Status "Éxito" -Message "7-Zip descargado y listo."
        } catch {
            Send-Log -Action "Descargando herramientas" -Status "Fallo" -Message "No se pudo descargar o extraer 7-Zip: $($_.Exception.Message)"
            $global:taskFailed = $true
            return $false
        }
    }
    return $true
}

# Descomprime un archivo usando 7za.exe
function Expand-CompressedFile {
    param(
        [string]$filePath,
        [string]$destination
    )
    if (-not (Ensure-7za)) { return }
    
    $7zaPath = Join-Path $global:scriptPath "7za.exe"
    $arguments = "x `"$filePath`" -o`"$destination`" -y"
    
    Send-Log -Action "Descomprimiendo" -Status "Éxito" -Message "Extrayendo '$filePath' a '$destination'..."

    $process = Start-Process -FilePath $7zaPath -ArgumentList $arguments -Wait -PassThru -NoNewWindow
    
    if ($process.ExitCode -ne 0) {
        Send-Log -Action "Descompresión" -Status "Fallo" -Message "7-Zip falló con código de salida: $($process.ExitCode)"
        $global:taskFailed = $true
    } else {
        Send-Log -Action "Descompresión" -Status "Éxito" -Message "Archivo extraído correctamente."
    }
}

# --- Tareas Principales ---
function Handle-UpdateTask {
    param($config)
    
    $global:taskFailed = $false
    $taskId = $config.id
    
    Send-Log -Action "Tarea recibida" -Status "Éxito" -Message "Iniciando tarea de tipo: $($config.packageType)" -TaskId $taskId

    try {
        # Paso 1: Detener servicios (si aplica)
        Stop-Services -serviceNames $config.serviceName

        # Paso 2: Ejecutar la acción principal según el tipo de paquete
        switch ($config.packageType) {
            "actualizacion_archivos" {
                Expand-CompressedFile -filePath $config.updateFilePath -destination $config.localUpdateDir
                if ($global:taskFailed) { throw "Fallo en la descompresión." }

                Send-Log -Action "Copiando archivos" -Status "Éxito" -Message "Copiando desde $($config.localUpdateDir) a $($config.installDir)" -TaskId $taskId
                Copy-Item -Path "$($config.localUpdateDir)\*" -Destination $config.installDir -Recurse -Force
                
                # Limpieza del directorio temporal
                if (Test-Path $config.localUpdateDir) {
                    Remove-Item -Path $config.localUpdateDir -Recurse -Force
                }
            }
            "ejecutar_script" {
                $scriptName = Split-Path $config.updateFilePath -Leaf
                $localScriptPath = Join-Path $global:scriptPath $scriptName
                Copy-Item -Path $config.updateFilePath -Destination $localScriptPath -Force
                
                Send-Log -Action "Ejecutando script" -Status "Éxito" -Message "Ejecutando '$localScriptPath'" -TaskId $taskId
                & $localScriptPath
            }
            "comando_powershell" {
                Send-Log -Action "Ejecutando comando" -Status "Éxito" -Message "Comando: $($config.command)" -TaskId $taskId
                Invoke-Expression $config.command | Out-String | Send-Log -Action "Salida de comando" -Status "Éxito" -TaskId $taskId
            }
            "registro_componentes" {
                # Lógica para manejar el registro de componentes...
                Send-Log -Action "Registro Componentes" -Status "Omitido" -Message "Funcionalidad pendiente de implementación." -TaskId $taskId
            }
        }

        # Paso 3: Ejecutar script post-instalación (si aplica)
        if (-not [string]::IsNullOrWhiteSpace($config.postInstallScript)) {
            Send-Log -Action "Post-Script" -Status "Éxito" -Message "Ejecutando script post-instalación." -TaskId $taskId
            try {
                Invoke-Expression $config.postInstallScript | Out-String | Send-Log -Action "Salida de Post-Script" -Status "Éxito" -TaskId $taskId
            } catch {
                Send-Log -Action "Post-Script" -Status "Fallo" -Message "Error en script post-instalación: $($_.Exception.Message)" -TaskId $taskId
                $global:taskFailed = $true
            }
        }

    } catch {
        Send-Log -Action "Error en Tarea" -Status "Fallo" -Message "Error general: $($_.Exception.Message)" -TaskId $taskId
        $global:taskFailed = $true
    } finally {
        # Paso 4: Reiniciar servicios (si aplica)
        Start-Services -serviceNames $config.serviceName

        # Paso 5: Reporte final
        if ($global:taskFailed) {
            Send-Log -Action "Actualización completada" -Status "Fallo" -Message "La tarea finalizó con errores." -VersionId $config.name -TaskId $taskId
        } else {
            Send-Log -Action "Actualización completada" -Status "Éxito" -Message "Tarea finalizada correctamente." -VersionId $config.name -TaskId $taskId
        }
    }
}

# --- Bucle Principal del Servicio ---
function Main-Loop {
    # Cargar configuración del servidor
    try {
        $configPath = Join-Path $global:scriptPath "config.json"
        $configContent = Get-Content $configPath -Raw | ConvertFrom-Json
        $global:serverUrl = $configContent.serverUrl
    } catch {
        Write-LocalLog "CRÍTICO: No se pudo leer o parsear 'config.json'. El agente no puede funcionar."
        return # Detiene la ejecución si no hay config
    }
    
    Send-Log -Action "Agente iniciado" -Status "Éxito" -Message "Agente versión $($global:agentVersion) iniciado."

    while ($true) {
        try {
            $pcId = Get-PCID
            $pcName = $env:COMPUTERNAME

            $checkBody = @{
                agentVersion = $global:agentVersion
                pcName = $pcName
            } | ConvertTo-Json

            # Envuelto en try/catch para resiliencia de red
            $response = $null
            try {
                 $response = Invoke-RestMethod -Uri "$($global:serverUrl)/api/tasks/check/$pcId" -Method Post -Body $checkBody -ContentType "application/json" -TimeoutSec 60
            } catch {
                 Write-LocalLog "WARN: No se pudo contactar al servidor: $($_.Exception.Message). Reintentando en el próximo ciclo."
                 Start-Sleep -Seconds 60 # Espera más tiempo si la red está caída
                 continue # Salta al siguiente ciclo del bucle
            }

            if ($response.task -eq "actualizar") {
                Handle-UpdateTask -config $response.config
            } elseif ($response.task -eq "actualizar_agente") {
                Send-Log -Action "Actualizando Agente" -Status "Éxito" -Message "Se recibió la orden de actualizar el agente."
                $installerPath = Join-Path $global:scriptPath "agent-installer-new.zip"
                Invoke-WebRequest -Uri "$($global:serverUrl)/api/download-agent" -OutFile $installerPath
                Expand-Archive -Path $installerPath -DestinationPath $global:scriptPath -Force
                Start-Process -FilePath (Join-Path $global:scriptPath "install-service.ps1")
                # El script de instalación detendrá este proceso, así que salimos.
                break
            } elseif ($response.task -eq "cancelar") {
                Send-Log -Action "Tarea Cancelada" -Status "Cancelado" -Message "Se recibió orden de cancelación del servidor." -TaskId $response.taskId
            }

            Start-Sleep -Seconds 15 # Espera normal entre verificaciones

        } catch {
            # Catch para errores inesperados en el bucle principal
            Write-LocalLog "ERROR INESPERADO en el bucle principal: $($_.Exception.Message)"
            Start-Sleep -Seconds 30
        }
    }
}

# --- Punto de Entrada ---
try {
    Main-Loop
} catch {
    Write-LocalLog "FATAL: El agente se ha detenido debido a un error crítico: $($_.Exception.Message)"
}
