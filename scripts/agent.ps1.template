# Clic Actualizador Tools Agent v1.4
# Este script se ejecuta como un servicio de Windows.
# Contacta periódicamente al servidor central para buscar tareas.

# --- CONFIGURACIÓN ---
$ErrorActionPreference = "Stop"
$agentVersion = "1.4"
$checkIntervalSeconds = 30 # Intervalo de sondeo en segundos

# --- INICIALIZACIÓN ---
$scriptPath = $MyInvocation.MyCommand.Path
$scriptDir = Split-Path -Path $scriptPath -Parent

# --- FUNCIONES ---

# Registra un mensaje localmente y lo envía al servidor
function Log-Message {
    param (
        [string]$action,
        [string]$status,
        [string]$message = "",
        [string]$versionId = $null,
        [string]$pcId,
        [string]$pcName,
        [string]$serverUrl,
        [string]$taskId = $null,
        [switch]$updatePcStatus,
        [object]$hardwareInfo = $null,
        [string]$agentVersion = $null,
        [string]$ip = $null,
        [string]$loggedUser = $null
    )

    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$status] $action - $message"
    Write-Output $logEntry
    
    # Enviar log al servidor
    try {
        $body = @{
            pcId = $pcId
            pcName = $pcName
            action = $action
            status = $status
            message = $message
        }
        if ($versionId) { $body.versionId = $versionId }
        if ($taskId) { $body.taskId = $taskId }
        if ($updatePcStatus) { 
            $body.agentVersion = $agentVersion
            $body.ip = $ip
            $body.loggedUser = $loggedUser
            $body.hardwareInfo = $hardwareInfo
        }

        $jsonBody = $body | ConvertTo-Json
        Invoke-RestMethod -Uri "$serverUrl/api/tasks/log" -Method Post -Body $jsonBody -ContentType "application/json" -TimeoutSec 10 | Out-Null
    } catch {
        Write-Warning "No se pudo enviar el log al servidor: $($_.Exception.Message)"
    }
}

# Comprueba si hay tareas pendientes en el servidor
function Check-For-Tasks {
    param($pcId, $pcName, $serverUrl, $agentVersion)

    try {
        # Recopilar información del sistema solo en la primera comprobación o periódicamente
        $ip = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias (Get-NetConnectionProfile).InterfaceAlias | Select-Object -ExpandProperty IPAddress)
        $loggedUser = (Get-CimInstance -ClassName Win32_ComputerSystem).UserName
        $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem
        $cpuInfo = Get-CimInstance -ClassName Win32_Processor
        $memInfo = Get-CimInstance -ClassName Win32_ComputerSystem
        $diskInfo = Get-CimInstance -ClassName Win32_DiskDrive | Select-Object Model, @{Name="Size";Expression={[math]::Round($_.Size / 1GB)}}
        
        $hardwareInfo = @{
            osName = $osInfo.Caption
            osVersion = $osInfo.Version
            cpuModel = $cpuInfo.Name
            cpuCores = $cpuInfo.NumberOfCores
            totalMemory = [math]::Round($memInfo.TotalPhysicalMemory / 1MB)
            disks = ($diskInfo | ConvertTo-Json -Compress)
        }

        # Comprobar 7za.exe
        $sevenZipPath = Join-Path $scriptDir "7za.exe"
        if (-not (Test-Path $sevenZipPath)) {
            Log-Message -action "Verificación del Agente" -status "Fallo" -message "No se encontró 7za.exe en $scriptDir. Las tareas de descompresión fallarán." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -updatePcStatus
            return
        }

        # Enviar petición al servidor
        $body = @{
            agentVersion = $agentVersion
            pcName = $pcName
        } | ConvertTo-Json
        
        $response = Invoke-RestMethod -Uri "$serverUrl/api/tasks/check/$pcId" -Method Post -Body $body -ContentType "application/json" -TimeoutSec 20

        # Procesar respuesta
        if ($response.task -eq 'actualizar_agente') {
            Log-Message -action "Auto-actualización" -status "Éxito" -message "Agente desactualizado. Iniciando actualización..." -pcId $pcId -pcName $pcName -serverUrl $serverUrl
            # Lógica para descargar y ejecutar el nuevo instalador
            $installerPath = Join-Path $scriptDir "install-service-new.ps1"
            Invoke-WebRequest -Uri "$serverUrl/api/download-agent" -OutFile (Join-Path $scriptDir "agent-new.zip")
            Expand-Archive -Path (Join-Path $scriptDir "agent-new.zip") -DestinationPath $scriptDir -Force
            Start-Process powershell.exe -ArgumentList "-ExecutionPolicy Bypass -File `"$installerPath`"" -Verb RunAs
            # El script se detendrá aquí para ser reemplazado
            exit
        } elseif ($response.task -eq 'cancelar') {
             Log-Message -action "Cancelación de tarea" -status "Cancelado" -message "Tarea ID $($response.taskId) cancelada por el servidor." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $response.taskId -updatePcStatus -hardwareInfo $hardwareInfo -agentVersion $agentVersion -ip $ip -loggedUser $loggedUser
        
        } elseif ($response.task -eq 'actualizar') {
            $config = $response.config
            $taskId = $response.taskId
            
            Log-Message -action "Tarea iniciada" -status "Éxito" -message "Recibida tarea '$($config.name)' (ID: $taskId)" -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
            Log-Message -action "Estado PC" -status "En progreso" -message "Ejecutando tarea: $($config.name)" -pcId $pcId -pcName $pcName -serverUrl $serverUrl -updatePcStatus -hardwareInfo $hardwareInfo -agentVersion $agentVersion -ip $ip -loggedUser $loggedUser
            
            $taskFailed = $false
            try {
                # --- LÓGICA DE EJECUCIÓN DE TAREAS ---
                switch ($config.packageType) {
                    "comando_powershell" {
                        Invoke-Expression -Command $config.command
                    }
                    "ejecutar_script" {
                        $tempScriptPath = Join-Path $env:TEMP ([System.IO.Path]::GetFileName($config.updateFilePath))
                        Copy-Item -Path $config.updateFilePath -Destination $tempScriptPath -Force
                        & $tempScriptPath
                    }
                    "actualizacion_archivos" {
                        # 1. Detener servicios
                        if ($config.serviceName) {
                            $services = $config.serviceName -split ',' | ForEach-Object { $_.Trim() }
                            foreach ($service in $services) {
                                if (Get-Service $service -ErrorAction SilentlyContinue) {
                                    Stop-Service -Name $service -Force
                                    Log-Message -action "Deteniendo servicio" -status "Éxito" -message "Servicio '$service' detenido." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
                                }
                            }
                        }

                        # 2. Descargar y extraer
                        $tempFilePath = Join-Path $env:TEMP ([System.IO.Path]::GetFileName($config.updateFilePath))
                        Copy-Item -Path $config.updateFilePath -Destination $tempFilePath -Force
                        & $sevenZipPath x "$tempFilePath" -o"$($config.localUpdateDir)" -y
                        
                        # 3. Copiar archivos
                        Copy-Item -Path "$($config.localUpdateDir)\*" -Destination $config.installDir -Recurse -Force -ErrorAction Stop
                        
                        # 4. Añadir a PATH si se especifica
                        if ($config.environmentPath) {
                            $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
                            $pathsToAdd = $config.environmentPath -split ';' | ForEach-Object { $_.Trim() }
                            foreach ($p in $pathsToAdd) {
                                if (-not ($currentPath -like "*$p*")) {
                                    $newPath = "$currentPath;$p"
                                    [Environment]::SetEnvironmentVariable("Path", $newPath, "Machine")
                                    Log-Message -action "Variable de entorno" -status "Éxito" -message "Ruta '$p' añadida al PATH del sistema." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
                                }
                            }
                        }
                    }
                    "registro_componentes" {
                        $xmlPath = Join-Path $env:TEMP "reg.xml"
                        Copy-Item -Path $config.updateFilePath -Destination $xmlPath -Force
                        
                        [xml]$regXml = Get-Content -Path $xmlPath

                        # Cambiar al directorio de los componentes para que los registros funcionen
                        Set-Location -Path $config.installDir

                        foreach ($componente in $regXml.COMPONENTES.COMPONENTE) {
                            $compName = $componente.Nombre
                            $compType = $componente.Tipo

                            try {
                                switch($compType) {
                                    "COMEXE" { & regsvr32.exe /s "$compName.exe" }
                                    "REGSVR32" { & regsvr32.exe /s "$compName" } # Asume extensión incluida
                                    "ASSEMBLY" { & "$env:SystemRoot\Microsoft.NET\Framework\v2.0.50727\RegAsm.exe" "$compName" /codebase /tlb }
                                    "ASSEMBLYv4" { & "$env:SystemRoot\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe" "$compName" /codebase /tlb }
                                }
                                Log-Message -action "Registro Componente" -status "Éxito" -message "Componente '$compName' ($compType) registrado." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
                            } catch {
                                Log-Message -action "Registro Componente" -status "Fallo" -message "Error al registrar '$compName': $($_.Exception.Message)" -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
                            }
                        }
                    }
                }
                
                # --- SCRIPT POST-INSTALACIÓN (SI EXISTE) ---
                if ($config.postInstallScript) {
                    Log-Message -action "Post-Instalación" -status "Éxito" -message "Ejecutando script post-instalación." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
                    
                    # CORRECCIÓN: Cambiar al directorio de instalación antes de ejecutar
                    if ($config.installDir -and (Test-Path $config.installDir)) {
                        Set-Location -Path $config.installDir
                    }

                    $postScriptPath = Join-Path $env:TEMP "post_script.ps1"
                    $config.postInstallScript | Out-File -FilePath $postScriptPath -Encoding utf8
                    & $postScriptPath
                }

            } catch {
                $taskFailed = $true
                Log-Message -action "Error en Tarea" -status "Fallo" -message $_.Exception.Message -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId
            }

            if ($taskFailed) {
                 Log-Message -action "Actualización completada" -status "Fallo" -message "La tarea '$($config.name)' finalizó con errores." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -taskId $taskId -updatePcStatus -hardwareInfo $hardwareInfo -agentVersion $agentVersion -ip $ip -loggedUser $loggedUser
            } else {
                 Log-Message -action "Actualización completada" -status "Éxito" -message "Tarea '$($config.name)' finalizada." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -versionId $config.name -taskId $taskId -updatePcStatus -hardwareInfo $hardwareInfo -agentVersion $agentVersion -ip $ip -loggedUser $loggedUser
            }
        } else {
             Log-Message -action "Sondeo" -status "Éxito" -message "No hay tareas pendientes." -pcId $pcId -pcName $pcName -serverUrl $serverUrl -updatePcStatus -hardwareInfo $hardwareInfo -agentVersion $agentVersion -ip $ip -loggedUser $loggedUser
        }
    } catch {
        Log-Message -action "Error de comunicación" -status "Fallo" -message "No se pudo contactar al servidor: $($_.Exception.Message)" -pcId $pcId -pcName $pcName -serverUrl $serverUrl -updatePcStatus -hardwareInfo $hardwareInfo -agentVersion $agentVersion -ip $ip -loggedUser $loggedUser
    }
}

# --- BUCLE PRINCIPAL ---
try {
    # Cargar configuración
    $configPath = Join-Path $scriptDir "config.json"
    if (-not (Test-Path $configPath)) {
        throw "El archivo de configuración 'config.json' no se encuentra en $scriptDir"
    }
    $config = Get-Content -Raw -Path $configPath | ConvertFrom-Json
    $serverUrl = $config.serverUrl
    
    # Obtener ID único de la máquina
    $pcId = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Cryptography" -Name "MachineGuid").MachineGuid
    $pcName = $env:COMPUTERNAME

    Write-Output "--- Agente Clic Actualizador Tools iniciado ---"
    Write-Output "ID de PC: $pcId"
    Write-Output "Servidor: $serverUrl"
    
    # Bucle infinito de sondeo
    while ($true) {
        Check-For-Tasks -pcId $pcId -pcName $pcName -serverUrl $serverUrl -agentVersion $agentVersion
        Start-Sleep -Seconds $checkIntervalSeconds
    }
} catch {
    Log-Message -action "Error Crítico del Agente" -status "Fallo" -message $_.Exception.Message -pcId $pcId -pcName $pcName -serverUrl $serverUrl
    Write-Error "Error crítico: $($_.Exception.Message)"
}
