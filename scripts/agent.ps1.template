# =================================================================
# AGENTE DE CLIENTE - Clic Actualizador Tools
# =================================================================

# --- CONFIGURACION INICIAL ---
$ErrorActionPreference = "Stop"

# Obten la ruta del script para encontrar el config.json y 7za.exe
$scriptPath = $MyInvocation.MyCommand.Path
$scriptDir = Split-Path -Path $scriptPath -Parent

# Carga la configuracion desde config.json
$configPath = Join-Path $scriptDir "config.json"
$config = Get-Content -Path $configPath | ConvertFrom-Json
$serverUrl = $config.serverUrl

# Version actual del agente (debe coincidir con la del servidor en lib/data.ts)
$agentVersion = "1.3"

# --- FUNCIONES AUXILIARES ---

# Funcion para enviar logs al servidor
function Send-Log {
    param(
        [string]$Action,
        [string]$Status,
        [string]$Message = "",
        [string]$VersionId = $null,
        [string]$TaskId = $null,
        [bool]$SendHardwareInfo = $false
    )
    $pcId = (Get-WmiObject Win32_ComputerSystemProduct).UUID
    $pcName = $env:COMPUTERNAME
    $ip = (Get-NetIPAddress -AddressFamily IPv4 -ErrorAction SilentlyContinue | Where-Object { $_.InterfaceAlias -notlike "Loopback*" } | Select-Object -First 1).IPAddress
    $loggedUser = (Get-WmiObject -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty UserName)

    $body = @{
        pcId = $pcId
        pcName = $pcName
        action = $Action
        status = $Status
        message = $Message
        versionId = $VersionId
        taskId = $TaskId
        agentVersion = $agentVersion
        ip = $ip
        loggedUser = $loggedUser
    }

    if ($SendHardwareInfo) {
        $osInfo = Get-WmiObject -Class Win32_OperatingSystem
        $cpuInfo = Get-WmiObject -Class Win32_Processor
        $memInfo = Get-WmiObject -Class Win32_ComputerSystem
        $diskInfo = Get-WmiObject -Class Win32_DiskDrive | Select-Object Model, @{Name="Size"; Expression={[math]::Round($_.Size / 1GB)}}
        
        $body.hardwareInfo = @{
            osName = $osInfo.Caption
            osVersion = $osInfo.Version
            cpuModel = $cpuInfo.Name
            cpuCores = $cpuInfo.NumberOfCores
            totalMemory = [math]::Round($memInfo.TotalPhysicalMemory / 1MB)
            disks = $diskInfo | ConvertTo-Json -Compress
        }
    }

    try {
        Invoke-RestMethod -Uri "$serverUrl/api/tasks/log" -Method Post -Body ($body | ConvertTo-Json) -ContentType "application/json"
    } catch {
        # No hacer nada si falla el log, para no entrar en bucles
    }
}

# --- INICIO DEL CICLO DEL AGENTE ---
Send-Log -Action "Agente iniciado" -Status "Éxito" -Message "Agente versión $agentVersion iniciado." -SendHardwareInfo $true

while ($true) {
    try {
        # 1. Contactar al servidor para ver si hay tareas
        $pcId = (Get-WmiObject Win32_ComputerSystemProduct).UUID
        $pcName = $env:COMPUTERNAME
        $checkBody = @{ agentVersion = $agentVersion; pcName = $pcName } | ConvertTo-Json
        $taskResponse = Invoke-RestMethod -Uri "$serverUrl/api/tasks/check/$pcId" -Method Post -Body $checkBody -ContentType "application/json"
        
        $task = $taskResponse.task
        $taskId = $taskResponse.taskId
        $config = $taskResponse.config

        # 2. Procesar la respuesta del servidor
        if ($task -eq "actualizar_agente") {
            # TAREA: AUTO-ACTUALIZACION DEL AGENTE
            Send-Log -Action "Auto-actualización del agente" -Status "Éxito" -Message "Agente desactualizado. Iniciando descarga de nueva versión."
            $downloadPath = Join-Path $scriptDir "new-agent.zip"
            Invoke-WebRequest -Uri "$serverUrl/api/download-agent" -OutFile $downloadPath
            Expand-Archive -Path $downloadPath -DestinationPath $scriptDir -Force
            Remove-Item $downloadPath
            
            # El install.bat se encarga de parar el servicio viejo e iniciar el nuevo
            Start-Process -FilePath (Join-Path $scriptDir "install.bat") -Verb RunAs
            exit # El agente viejo termina su ejecución
        
        } elseif ($task -eq "cancelar") {
            # TAREA: CANCELAR
            Send-Log -Action "Tarea cancelada" -Status "Cancelado" -Message "El servidor ordenó cancelar la tarea actual." -TaskId $taskId
            # El agente simplemente reporta y esperará una nueva tarea en el próximo ciclo

        } elseif ($task -eq "actualizar") {
            # TAREA: EJECUTAR UN PAQUETE
            $packageType = $config.packageType

            Send-Log -Action "Tarea recibida" -Status "Éxito" -Message "Iniciando tarea '$($config.name)' de tipo '$packageType'." -TaskId $taskId
            
            # --- Lógica según el tipo de paquete ---

            if ($packageType -eq "actualizacion_archivos") {
                # ----- TIPO: ACTUALIZACION DE ARCHIVOS -----
                $sourcePath = $config.updateFilePath
                $localDir = $config.localUpdateDir
                $installDir = $config.installDir
                $services = $config.serviceName
                $sevenZipPath = Join-Path $scriptDir "7za.exe"

                # Limpiar directorio local
                if (Test-Path $localDir) { Remove-Item -Recurse -Force $localDir }
                New-Item -Path $localDir -ItemType Directory

                # Detener servicios
                if (![string]::IsNullOrWhiteSpace($services)) {
                    $serviceList = $services -split ',' | ForEach-Object { $_.Trim() }
                    foreach ($s in $serviceList) {
                        Send-Log -Action "Deteniendo servicio" -Status "Éxito" -Message "Intentando detener el servicio: $s" -TaskId $taskId
                        Stop-Service -Name $s -Force -ErrorAction SilentlyContinue
                    }
                }

                # Descargar y descomprimir
                Send-Log -Action "Descargando" -Status "Éxito" -Message "Copiando $sourcePath..." -TaskId $taskId
                Copy-Item -Path $sourcePath -Destination $localDir
                $localFile = Join-Path $localDir (Split-Path $sourcePath -Leaf)

                # Desbloquear archivo
                Unblock-File -Path $localFile

                Send-Log -Action "Descomprimiendo" -Status "Éxito" -Message "Extrayendo $localFile..." -TaskId $taskId
                Start-Process -FilePath $sevenZipPath -ArgumentList "x `"$localFile`" -o`"$localDir`" -y" -Wait -NoNewWindow

                # Copiar archivos a destino
                Send-Log -Action "Copiando archivos" -Status "Éxito" -Message "Copiando a $installDir..." -TaskId $taskId
                Copy-Item -Path (Join-Path $localDir "*") -Destination $installDir -Recurse -Force

                # Registrar componentes si ERPReg.xml existe
                $erpRegPath = Join-Path $localDir "Registro\ERPReg.xml"
                if (Test-Path $erpRegPath) {
                    Send-Log -Action "Registrando Componentes" -Status "Éxito" -Message "Se encontró ERPReg.xml. Registrando componentes..." -TaskId $taskId
                    # Simulación de registro, en un caso real aquí iría la lógica con regsvr32, etc.
                    Start-Sleep -Seconds 5 
                }

                # Añadir a variable de entorno PATH si se especifica
                if (![string]::IsNullOrWhiteSpace($config.environmentPath)) {
                    # Lógica para añadir al PATH del sistema
                }

                # Tarea completada
                $versionId = (Get-Content (Join-Path $installDir "Version.txt") -ErrorAction SilentlyContinue)
                Send-Log -Action "Actualización completada" -Status "Éxito" -Message "La tarea se completó con éxito." -VersionId $versionId -TaskId $taskId

            } elseif ($packageType -eq "ejecutar_script") {
                # ----- TIPO: EJECUTAR SCRIPT -----
                $scriptSourcePath = $config.updateFilePath
                $localScriptDir = Join-Path $env:TEMP "ClicUpdaterScripts"
                if (Test-Path $localScriptDir) { Remove-Item -Recurse -Force $localScriptDir }
                New-Item -Path $localScriptDir -ItemType Directory

                Send-Log -Action "Descargando Script" -Status "Éxito" -Message "Copiando $scriptSourcePath..." -TaskId $taskId
                Copy-Item -Path $scriptSourcePath -Destination $localScriptDir
                $localScriptPath = Join-Path $localScriptDir (Split-Path $scriptSourcePath -Leaf)
                
                Unblock-File -Path $localScriptPath

                Send-Log -Action "Ejecutando Script" -Status "Éxito" -Message "Ejecutando $localScriptPath..." -TaskId $taskId
                
                $process = Start-Process -FilePath $localScriptPath -Wait -PassThru -NoNewWindow
                if ($process.ExitCode -ne 0) {
                    throw "El script finalizó con código de error $($process.ExitCode)."
                }
                
                Send-Log -Action "Script completado" -Status "Éxito" -Message "El script se ejecutó correctamente." -TaskId $taskId

            } elseif ($packageType -eq "comando_powershell") {
                # ----- TIPO: COMANDO POWERSHELL -----
                $commandToRun = $config.command
                Send-Log -Action "Ejecutando Comando" -Status "Éxito" -Message "Comando: $commandToRun" -TaskId $taskId

                # Ejecutar el comando
                $output = Invoke-Expression $commandToRun
                
                Send-Log -Action "Comando completado" -Status "Éxito" -Message "El comando se ejecutó. Salida: $output" -TaskId $taskId
            }

            Start-Sleep -Seconds 5
        }

    } catch {
        # Manejo de errores global
        $errorMessage = $_.Exception.Message
        Send-Log -Action "Error en Agente" -Status "Fallo" -Message "Error en el ciclo principal: $errorMessage" -TaskId $taskId
    }

    # Esperar antes del siguiente ciclo
    Start-Sleep -Seconds 60 
}
