# Softland Updater Agent
# Version: 1.1

# --- Configuracion ---
$ServerUrl = "__SERVER_URL__"
$PcId = "__PC_ID__"
$AgentVersion = "1.1" # Esta es la version del agente. Debe coincidir con LATEST_AGENT_VERSION en el servidor.
$TempDir = $env:TEMP
$PauseIntervalSeconds = 60 # Tiempo de espera entre verificaciones si no hay tareas

# --- Funciones ---

# Funcion para enviar logs al servidor
function Send-Log {
    param(
        [string]$Action,
        [string]$Status,
        [string]$Message = "",
        [string]$VersionId = $null,
        [string]$TaskId = $null,
        [object]$HardwareInfo = $null
    )
    
    $pcName = $env:COMPUTERNAME
    $ip = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias (Get-NetConnectionProfile).InterfaceAlias).IPAddress
    $loggedUser = (Get-WmiObject -ClassName Win32_ComputerSystem).UserName

    $body = @{
        pcId = $PcId
        pcName = $pcName
        action = $Action
        status = $Status
        message = $Message
        versionId = $VersionId
        taskId = $TaskId
        agentVersion = $AgentVersion
        ip = $ip
        loggedUser = $loggedUser
    }

    # Anadir informacion de hardware solo si se proporciona
    if ($null -ne $HardwareInfo) {
        $body.Add("hardwareInfo", $HardwareInfo)
    }

    $jsonBody = $body | ConvertTo-Json -Depth 4
    
    try {
        Invoke-RestMethod -Uri "$ServerUrl/api/tasks/log" -Method Post -Body $jsonBody -ContentType "application/json" -TimeoutSec 30
    } catch {
        # Fallo al enviar el log, se imprime en la consola del agente (visible en debug)
        Write-Output "Error al enviar log: $($_.Exception.Message)"
    }
}

# Funcion para recolectar informacion del hardware
function Get-HardwareInfo {
    $os = Get-WmiObject -Class Win32_OperatingSystem
    $cpu = Get-WmiObject -Class Win32_Processor
    $mem = Get-WmiObject -Class Win32_ComputerSystem
    $disks = Get-WmiObject -Class Win32_DiskDrive | Where-Object { $_.MediaType -eq "Fixed hard disk media" -or $_.MediaType -like "*SSD*" }
    
    $diskInfo = @()
    foreach ($disk in $disks) {
        $diskInfo += @{
            model = $disk.Model
            size = [math]::Round($disk.Size / 1GB)
        }
    }

    return @{
        osName = $os.Caption
        osVersion = $os.Version
        cpuModel = $cpu.Name
        cpuCores = $cpu.NumberOfLogicalProcessors
        totalMemory = [math]::Round($mem.TotalPhysicalMemory / 1MB)
        disks = $diskInfo | ConvertTo-Json -Compress
    }
}

# Funcion para registrar componentes de Softland segun ERPReg.xml
function Register-SoftlandComponents {
    param(
        [string]$InstallDir
    )
    $regXmlPath = Join-Path $InstallDir "ERPReg.xml"
    if (-not (Test-Path $regXmlPath)) {
        Send-Log -Action "Registro de Componentes" -Status "Omitido" -Message "Archivo ERPReg.xml no encontrado."
        return
    }

    Send-Log -Action "Registro de Componentes" -Status "Exito" -Message "Iniciando registro basado en ERPReg.xml."
    $xml = [xml](Get-Content $regXmlPath)
    $regAsmPath = Join-Path ([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory()) "RegAsm.exe"
    $regAsmPathV4 = Join-Path (${env:SystemRoot} + "\Microsoft.NET\Framework\v4.0.30319") "RegAsm.exe"


    foreach ($componente in $xml.COMPONENTES.COMPONENTE) {
        $componentePath = Join-Path $InstallDir $componente.Nombre
        $logMessage = "Registrando $($componente.Nombre)"

        try {
            switch ($componente.Tipo) {
                "REGSVR32" {
                    Start-Process "regsvr32.exe" -ArgumentList "/s `"$componentePath`"" -Wait
                }
                "ASSEMBLY" {
                    Start-Process $regAsmPath -ArgumentList "/silent /codebase `"$componentePath`"" -Wait
                }
                "ASSEMBLYv4" {
                    Start-Process $regAsmPathV4 -ArgumentList "/silent /codebase `"$componentePath`"" -Wait
                }
                "COMEXE" {
                    Start-Process $componentePath -ArgumentList "/regserver" -Wait
                }
                default {
                    $logMessage = "Tipo de componente $($componente.Tipo) no soportado para $($componente.Nombre)."
                }
            }
            Send-Log -Action "Registro de Componentes" -Status "Exito" -Message $logMessage
        } catch {
            Send-Log -Action "Registro de Componentes" -Status "Fallo" -Message "Error registrando $($componente.Nombre): $($_.Exception.Message)"
        }
    }
}


# --- Ciclo Principal del Agente ---
while ($true) {
    try {
        # 1. Comprobar tareas
        $checkBody = @{ agentVersion = $AgentVersion } | ConvertTo-Json
        $response = Invoke-RestMethod -Uri "$ServerUrl/api/tasks/check/$PcId" -Method Post -Body $checkBody -ContentType "application/json"

        # 2. Decidir accion basada en la respuesta
        switch ($response.task) {
            "actualizar_agente" {
                Send-Log -Action "Auto-Actualizacion Agente" -Status "Exito" -Message "Version de agente desactualizada. Iniciando descarga."
                $agentZipPath = Join-Path $TempDir "softland-agent-update.zip"
                Invoke-WebRequest -Uri "$ServerUrl/api/download-agent?forUpdate=true" -OutFile $agentZipPath
                
                $unzipDir = Join-Path $TempDir "softland-agent-update-pkg"
                if (Test-Path $unzipDir) { Remove-Item -Path $unzipDir -Recurse -Force }
                Expand-Archive -Path $agentZipPath -DestinationPath $unzipDir -Force
                
                # Ejecutar el nuevo instalador. Este se encargara de desinstalar la version vieja.
                $installScriptPath = Join-Path $unzipDir "install-service.ps1"
                Start-Process powershell.exe -ArgumentList "-ExecutionPolicy Bypass -File `"$installScriptPath`" -noninteractive" -Verb RunAs
                
                # Detener el servicio actual para que el nuevo instalador pueda reemplazarlo
                Stop-Service -Name "SoftlandUpdateAgent_$(($env:COMPUTERNAME).replace('-', ''))" -Force
                exit # El agente antiguo termina su ejecucion
            }

            "cancelar" {
                Send-Log -Action "Cancelacion de Tarea" -Status "Exito" -Message "Tarea $($response.taskId) cancelada por el servidor." -TaskId $response.taskId
            }

            "actualizar" {
                # Proceso de actualizacion de Softland
                $taskId = $response.taskId
                $config = $response.config
                $versionId = ([System.IO.Path]::GetFileNameWithoutExtension($config.updateFilePath)).Replace("_",".")

                Send-Log -Action "Inicio de actualizacion" -Status "Exito" -Message "Iniciando proceso para $versionId" -TaskId $taskId

                # Verificar si ya esta actualizado
                $currentVersionReg = Get-ItemProperty -Path "HKLM:\Software\Softland" -Name "Version" -ErrorAction SilentlyContinue
                if ($currentVersionReg -and $currentVersionReg.Version -eq $versionId) {
                    Send-Log -Action "Version ya actualizada" -Status "Omitido" -Message "La PC ya tiene la version $versionId." -VersionId $versionId -TaskId $taskId
                    Start-Sleep -Seconds $PauseIntervalSeconds
                    continue
                }

                # Detener servicios
                Send-Log -Action "Deteniendo servicios" -Status "Exito" -Message "Deteniendo: $($config.serviceName)" -TaskId $taskId
                $serviceNames = $config.serviceName.Split(',') | ForEach-Object { $_.Trim() }
                foreach ($sName in $serviceNames) {
                    try {
                        Stop-Process -Name $sName -Force -ErrorAction Stop
                        Send-Log -Action "Deteniendo Proceso" -Status "Exito" -Message "Proceso '$sName' detenido." -TaskId $taskId
                    } catch {
                        Send-Log -Action "Deteniendo Proceso" -Status "Omitido" -Message "Proceso '$sName' no encontrado o ya detenido." -TaskId $taskId
                    }
                }

                # Copiar y extraer
                $localUpdateDir = $config.localUpdateDir
                if (-not (Test-Path $localUpdateDir)) { New-Item -Path $localUpdateDir -ItemType Directory }
                $updateFile = $config.updateFilePath
                $localUpdateFile = Join-Path $localUpdateDir ([System.IO.Path]::GetFileName($updateFile))

                Send-Log -Action "Copiando archivos" -Status "Exito" -Message "Copiando desde $updateFile" -TaskId $taskId
                Copy-Item -Path $updateFile -Destination $localUpdateFile -Force

                Send-Log -Action "Extrayendo archivos" -Status "Exito" -Message "Extrayendo en $($config.softlandInstallDir)" -TaskId $taskId
                $7zaPath = Join-Path $PSScriptRoot "7za.exe"
                Start-Process -FilePath $7zaPath -ArgumentList "x `"$localUpdateFile`" -o`"$($config.softlandInstallDir)`" -y" -Wait
                
                # Desbloquear archivos
                Send-Log -Action "Desbloqueando archivos" -Status "Exito" -Message "Desbloqueando en $($config.softlandInstallDir)" -TaskId $taskId
                Get-ChildItem -Path $config.softlandInstallDir -Recurse | Unblock-File
                
                # Registrar Componentes
                Register-SoftlandComponents -InstallDir $config.softlandInstallDir

                # Guardar nueva version en el registro
                $regPath = "HKLM:\Software\Softland"
                if (-not (Test-Path $regPath)) { New-Item -Path $regPath -Force }
                New-ItemProperty -Path $regPath -Name "Version" -Value $versionId -PropertyType String -Force

                # Enviar reporte de hardware y finalizacion
                $hwInfo = Get-HardwareInfo
                Send-Log -Action "Actualizacion completada" -Status "Exito" -Message "Version $versionId instalada." -VersionId $versionId -TaskId $taskId -HardwareInfo $hwInfo
            }

            default { # 'ninguna'
                # No hacer nada, solo esperar
            }
        }
    } catch {
        # Error general en el ciclo, se envia log de fallo
        Send-Log -Action "Error de Agente" -Status "Fallo" -Message "Error inesperado: $($_.Exception.Message)"
    }
    
    # Esperar antes de la proxima verificacion
    Start-Sleep -Seconds $PauseIntervalSeconds
}
