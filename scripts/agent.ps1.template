# Clic Actualizador Tools Agent v1.3
# Este script se ejecuta como un servicio de Windows.
# Escucha las órdenes del servidor y ejecuta las tareas de actualización.

# --- INICIO: Determinar directorio de ejecución ---
# Esto es CRÍTICO para que el servicio encuentre los archivos config.json y 7za.exe
$scriptPath = $MyInvocation.MyCommand.Path
$scriptDir = Split-Path -Parent $scriptPath
# --- FIN: Determinar directorio de ejecución ---

$configFile = Join-Path $scriptDir "config.json"
$sevenZipPath = Join-Path $scriptDir "7za.exe"

$ErrorActionPreference = "SilentlyContinue"

# Función para enviar logs al servidor
function Send-Log {
    param(
        [string]$Action,
        [string]$Status,
        [string]$Message,
        [string]$VersionId,
        [string]$TaskId,
        [hashtable]$ExtraData = @{}
    )
    
    $pcId = Get-WmiObject Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID
    $pcName = $env:COMPUTERNAME
    $agentVersion = "1.3" # Coincide con LATEST_AGENT_VERSION en el servidor
    $ipAddress = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias (Get-NetConnectionProfile).InterfaceAlias).IPAddress
    $loggedUser = (Get-WmiObject -ClassName Win32_ComputerSystem).UserName
    
    $hardware = @{}
    if ($Action -eq 'Reporte de estado inicial') {
        $osInfo = Get-WmiObject -Class Win32_OperatingSystem
        $cpuInfo = Get-WmiObject -Class Win32_Processor
        $memInfo = Get-WmiObject -Class Win32_ComputerSystem
        $diskInfo = Get-WmiObject -Class Win32_DiskDrive | Select-Object Model, @{Name="Size"; Expression={[math]::Round($_.Size / 1GB)}}
        
        $hardware = @{
            osName = $osInfo.Caption
            osVersion = $osInfo.Version
            cpuModel = $cpuInfo.Name
            cpuCores = $cpuInfo.NumberOfCores
            totalMemory = [math]::Round($memInfo.TotalPhysicalMemory / 1MB)
            disks = $diskInfo | ConvertTo-Json -Compress
        }
    }

    $body = @{
        pcId = $pcId
        pcName = $pcName
        action = $Action
        status = $Status
        message = $Message
        versionId = $VersionId
        taskId = $TaskId
        agentVersion = $agentVersion
        ip = $ipAddress
        loggedUser = $loggedUser
        hardwareInfo = $hardware
    }
    
    $body.putAll($ExtraData)

    $config = Get-Content $configFile | ConvertFrom-Json
    $logUrl = "$($config.serverUrl)/api/tasks/log"
    
    try {
        Invoke-RestMethod -Uri $logUrl -Method Post -Body ($body | ConvertTo-Json) -ContentType "application/json" -TimeoutSec 30
    } catch {
        # Fallo al enviar el log, no hacer nada para evitar bucles infinitos.
        # En un futuro se podría guardar en un archivo local para reintentar.
    }
}


# --- Lógica principal ---
$pcId = Get-WmiObject Win32_ComputerSystemProduct | Select-Object -ExpandProperty UUID
$pcName = $env:COMPUTERNAME

if (-not (Test-Path $configFile)) {
    # No se puede operar sin configuración. El servicio fallará, pero es lo esperado.
    return
}

$config = Get-Content $configFile | ConvertFrom-Json
$checkUrl = "$($config.serverUrl)/api/tasks/check/$pcId"

# Reporte de estado inicial al arrancar el servicio
Send-Log -Action "Reporte de estado inicial" -Status "Éxito" -Message "El agente se ha iniciado correctamente."

# Bucle infinito para verificar tareas
while ($true) {
    try {
        $body = @{ agentVersion = "1.3"; pcName = $pcName } | ConvertTo-Json
        $response = Invoke-RestMethod -Uri $checkUrl -Method Post -Body $body -ContentType "application/json" -TimeoutSec 60
        
        if ($response.task -eq "actualizar") {
            $taskId = $response.taskId
            $pkg = $response.config

            Send-Log -Action "Tarea recibida" -Status "Éxito" -Message "Iniciando tarea: $($pkg.name)" -TaskId $taskId
            
            $currentVersionId = $pkg.name # O un hash del archivo si fuera necesario

            # --- Detener servicios ---
            if ($pkg.serviceName) {
                $services = $pkg.serviceName.Split(',') | ForEach-Object { $_.Trim() }
                foreach ($service in $services) {
                    if (Get-Service $service -ErrorAction SilentlyContinue) {
                        Send-Log -Action "Deteniendo servicio" -Status "Éxito" -Message "Deteniendo servicio: $service" -TaskId $taskId
                        Stop-Service -Name $service -Force
                    }
                }
            }

            # --- EJECUCIÓN SEGÚN TIPO DE PAQUETE ---
            if ($pkg.packageType -eq "actualizacion_archivos") {
                # 1. Copiar y extraer archivo
                Send-Log -Action "Descargando" -Status "Éxito" -Message "Copiando archivo desde: $($pkg.updateFilePath)" -TaskId $taskId
                if (-not (Test-Path $pkg.localUpdateDir)) { New-Item -Path $pkg.localUpdateDir -ItemType Directory -Force }
                Copy-Item -Path $pkg.updateFilePath -Destination $pkg.localUpdateDir -Force
                $updateFile = Join-Path $pkg.localUpdateDir (Split-Path $pkg.updateFilePath -Leaf)
                
                Send-Log -Action "Extrayendo" -Status "Éxito" -Message "Extrayendo archivo: $updateFile" -TaskId $taskId
                & $sevenZipPath x $updateFile -o"$($pkg.localUpdateDir)" -y | Out-Null
                
                # 2. Copiar archivos
                Send-Log -Action "Copiando archivos" -Status "Éxito" -Message "Copiando archivos a: $($pkg.installDir)" -TaskId $taskId
                Copy-Item -Path "$($pkg.localUpdateDir)\\*" -Destination $pkg.installDir -Recurse -Force

                # 3. Limpiar
                Remove-Item -Path $pkg.localUpdateDir -Recurse -Force
            
            } elseif ($pkg.packageType -eq "ejecutar_script") {
                Send-Log -Action "Descargando script" -Status "Éxito" -Message "Copiando script desde: $($pkg.updateFilePath)" -TaskId $taskId
                $tempScriptDir = Join-Path $env:TEMP "ClicUpdaterTask"
                if (-not (Test-Path $tempScriptDir)) { New-Item -Path $tempScriptDir -ItemType Directory -Force }
                Copy-Item -Path $pkg.updateFilePath -Destination $tempScriptDir -Force
                $scriptToRun = Join-Path $tempScriptDir (Split-Path $pkg.updateFilePath -Leaf)

                Send-Log -Action "Ejecutando script" -Status "Éxito" -Message "Ejecutando: $scriptToRun" -TaskId $taskId
                Start-Process -FilePath $scriptToRun -Wait -NoNewWindow
                
                Remove-Item -Path $tempScriptDir -Recurse -Force
            
            } elseif ($pkg.packageType -eq "comando_powershell") {
                Send-Log -Action "Ejecutando comando PS" -Status "Éxito" -Message "Ejecutando: $($pkg.command)" -TaskId $taskId
                Invoke-Expression -Command $pkg.command
            }

            # --- Iniciar servicios ---
            if ($pkg.serviceName) {
                 $services = $pkg.serviceName.Split(',') | ForEach-Object { $_.Trim() }
                foreach ($service in $services) {
                    if (Get-Service $service -ErrorAction SilentlyContinue) {
                        Send-Log -Action "Iniciando servicio" -Status "Éxito" -Message "Iniciando servicio: $service" -TaskId $taskId
                        Start-Service -Name $service
                    }
                }
            }

            # --- Añadir al PATH si es necesario ---
            if ($pkg.environmentPath) {
                $cleanPath = $pkg.environmentPath.TrimEnd(';')
                $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
                $pathsToAdd = $cleanPath.Split(';') | Where-Object { $currentPath -notlike "*$($_)*" }
                if ($pathsToAdd) {
                    $newPath = $currentPath + ";" + ($pathsToAdd -join ";")
                    [Environment]::SetEnvironmentVariable("Path", $newPath, "Machine")
                    Send-Log -Action "Actualizando PATH" -Status "Éxito" -Message "Rutas añadidas al PATH del sistema." -TaskId $taskId
                }
            }

            Send-Log -Action "Actualización completada" -Status "Éxito" -Message "La tarea se completó correctamente." -VersionId $currentVersionId -TaskId $taskId

        } elseif ($response.task -eq "cancelar") {
            # El servidor ya sabe que la tarea fue cancelada, aquí solo logueamos localmente.
            # En un futuro, se podría usar $response.taskId para detener un proceso en curso.
            Send-Log -Action "Tarea Cancelada" -Status "Cancelado" -Message "La tarea actual fue cancelada desde el servidor." -TaskId $response.taskId
        }
        
        # Pausa antes de la siguiente verificación
        Start-Sleep -Seconds 30
        
    } catch {
        # Error al conectar con el servidor o en la ejecución.
        # Loguear el error y continuar el bucle.
        Send-Log -Action "Error de agente" -Status "Fallo" -Message "Error en el bucle principal: $($_.Exception.Message)"
        Start-Sleep -Seconds 60 # Esperar más tiempo si hay un error
    }
}
