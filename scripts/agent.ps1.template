# Clic Actualizador Tools - Agente de Ejecución
# Versión: 1.3
# Este script se ejecuta en un bucle infinito en la PC cliente.
# Contacta al servidor para verificar si hay tareas pendientes y las ejecuta.

# --- Configuración Inicial y Funciones de Logging ---

# Establecer la preferencia de error para que los errores detengan el script y puedan ser capturados.
$ErrorActionPreference = "Stop"

# Alcance global para la bandera de fallo de tarea.
$global:taskFailed = $false

# Obtener la ruta del script para localizar otros archivos necesarios (config.json, 7za.exe)
$scriptPath = $PSScriptRoot

# Función para enviar logs al servidor central.
function Log-ToServer {
    param(
        [string]$Action,
        [string]$Status,
        [string]$Message,
        [string]$VersionId,
        [string]$TaskId
    )
    
    try {
        $hardwareInfo = $null
        # Solo recolectar información de hardware en el primer log ("Heartbeat") para eficiencia.
        if ($Action -eq "Heartbeat") {
            try {
                $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem
                $cpuInfo = Get-CimInstance -ClassName Win32_Processor
                $memInfo = Get-CimInstance -ClassName Win32_ComputerSystem
                $diskInfo = Get-CimInstance -ClassName Win32_DiskDrive | Select-Object Model, @{Name="Size";Expression={[math]::Round($_.Size / 1GB)}}
                
                $hardwareInfo = @{
                    osName = $osInfo.Caption
                    osVersion = $osInfo.Version
                    cpuModel = $cpuInfo.Name
                    cpuCores = $cpuInfo.NumberOfCores
                    totalMemory = [math]::Round($memInfo.TotalPhysicalMemory / 1MB)
                    disks = ($diskInfo | ConvertTo-Json -Compress)
                }
            } catch {
                # No detener el script si la recolección de hardware falla.
                Write-Warning "No se pudo recolectar la información de hardware: $($_.Exception.Message)"
            }
        }

        $body = @{
            pcId = $config.pcId
            pcName = $env:COMPUTERNAME
            action = $Action
            status = $Status
            message = $Message
            versionId = $VersionId
            taskId = $TaskId
            agentVersion = $agentVersion
            ip = (Test-Connection -ComputerName $env:COMPUTERNAME -Count 1).IPV4Address.IPAddressToString
            loggedUser = (Get-CimInstance -ClassName Win32_ComputerSystem).UserName
            hardwareInfo = $hardwareInfo
        } | ConvertTo-Json -Depth 5

        # Usar -UseBasicParsing para compatibilidad con versiones antiguas de PowerShell.
        Invoke-RestMethod -Uri "$($config.serverUrl)/api/tasks/log" -Method Post -Body $body -ContentType "application/json" -UseBasicParsing
    } catch {
        Write-Error "CRÍTICO: No se pudo enviar el log al servidor. Error: $($_.Exception.Message)"
    }
}

# --- Carga de Configuración e Inicialización ---

# Cargar la configuración desde config.json
$configPath = Join-Path $scriptPath "config.json"
if (-not (Test-Path $configPath)) {
    Write-Error "No se encontró el archivo config.json en $scriptPath. El agente no puede iniciar."
    Start-Sleep -Seconds 60
    exit
}
$config = Get-Content $configPath | ConvertFrom-Json

# Asignar un ID de PC si no existe (basado en el MAC para unicidad).
if (-not $config.pcId) {
    $macAddress = (Get-CimInstance Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled }).MACAddress | Select-Object -First 1
    $config.pcId = $macAddress -replace ':', ''
    $config | ConvertTo-Json | Set-Content $configPath
}

# Verificar la existencia de 7za.exe.
$sevenZipPath = Join-Path $scriptPath "7za.exe"
if (-not (Test-Path $sevenZipPath)) {
    Log-ToServer -Action "Error de Agente" -Status "Fallo" -Message "No se encontró 7za.exe. Las tareas de descompresión fallarán."
}


$agentVersion = "1.3"
$lastHeartbeat = [datetime]::MinValue

# --- Bucle Principal del Agente ---

Write-Host "Agente Clic Actualizador Tools v$agentVersion iniciado. Presione CTRL+C para detener."

while ($true) {
    try {
        # Enviar un "heartbeat" cada 5 minutos para que el servidor sepa que el agente está vivo.
        if ([datetime]::Now -gt $lastHeartbeat.AddMinutes(5)) {
            Log-ToServer -Action "Heartbeat" -Status "Éxito" -Message "Agente activo y escuchando."
            $lastHeartbeat = [datetime]::Now
        }

        # Consultar al servidor por nuevas tareas.
        $checkBody = @{ agentVersion = $agentVersion; pcName = $env:COMPUTERNAME } | ConvertTo-Json
        $response = Invoke-RestMethod -Uri "$($config.serverUrl)/api/tasks/check/$($config.pcId)" -Method Post -Body $checkBody -ContentType "application/json" -UseBasicParsing

        # --- Procesamiento de Tareas ---

        if ($response.task -eq "ninguna") {
            # No hay tareas, esperar y volver a consultar.
            Start-Sleep -Seconds 15
            continue
        }

        # Resetear la bandera de fallo para la nueva tarea.
        $global:taskFailed = $false

        if ($response.task -eq "actualizar_agente") {
            # Tarea de máxima prioridad: auto-actualización del agente.
            # (Lógica a ser implementada en futuras versiones)
            Log-ToServer -Action "Auto-Actualización" -Status "Omitido" -Message "Funcionalidad de auto-actualización pendiente."
            Start-Sleep -Seconds 300 # Esperar 5 minutos antes de volver a consultar para evitar bucles.
            continue
        }

        if ($response.task -eq "cancelar") {
            Log-ToServer -Action "Cancelación de Tarea" -Status "Éxito" -Message "Tarea con ID $($response.taskId) cancelada por el servidor." -TaskId $response.taskId
            continue
        }

        # --- Ejecución de Tarea de Actualización ---

        if ($response.task -eq "actualizar") {
            $taskConfig = $response.config
            $taskId = $response.taskId
            Log-ToServer -Action "Inicio de Tarea" -Status "Éxito" -Message "Iniciando tarea para paquete '$($taskConfig.name)'." -TaskId $taskId
            
            $servicesToRestart = @()

            try {
                # 1. Detener servicios (si se especifican)
                if (-not [string]::IsNullOrWhiteSpace($taskConfig.serviceName)) {
                    $serviceNames = $taskConfig.serviceName.Split(',') | ForEach-Object { $_.Trim() }
                    foreach ($service in $serviceNames) {
                        try {
                            $serviceObj = Get-Service -Name $service -ErrorAction Stop
                            if ($serviceObj.Status -eq 'Running') {
                                Log-ToServer -Action "Deteniendo Servicio" -Status "Éxito" -Message "Deteniendo servicio '$service'..." -TaskId $taskId
                                Stop-Service -Name $service -Force
                                $servicesToRestart += $service # Añadir a la lista para reiniciar después
                            }
                        } catch {
                            Log-ToServer -Action "Deteniendo Servicio" -Status "Fallo" -Message "No se pudo detener el servicio '$service': $($_.Exception.Message)" -TaskId $taskId
                        }
                    }
                }

                # 2. Ejecutar la lógica principal según el tipo de paquete
                switch ($taskConfig.packageType) {
                    "actualizacion_archivos" {
                        # Lógica para descomprimir y copiar archivos
                        $localZipPath = Join-Path $taskConfig.localUpdateDir "$([System.IO.Path]::GetFileName($taskConfig.updateFilePath))"
                        New-Item -Path $taskConfig.localUpdateDir -ItemType Directory -Force | Out-Null
                        Copy-Item -Path $taskConfig.updateFilePath -Destination $localZipPath -Force
                        Log-ToServer -Action "Descompresión" -Status "Éxito" -Message "Extrayendo archivos en '$($taskConfig.installDir)'..." -TaskId $taskId
                        
                        & $sevenZipPath x $localZipPath -o"$($taskConfig.installDir)" -y | Out-Null
                        
                        Remove-Item $localZipPath -Force
                        Log-ToServer -Action "Limpieza" -Status "Éxito" -Message "Archivos temporales eliminados." -TaskId $taskId
                    }
                    "ejecutar_script" {
                        $scriptPathFromNetwork = $taskConfig.updateFilePath
                        $localScriptPath = Join-Path $PSScriptRoot "temp_exec_script.ps1"
                        Copy-Item -Path $scriptPathFromNetwork -Destination $localScriptPath -Force
                        Log-ToServer -Action "Ejecutando Script" -Status "Éxito" -Message "Ejecutando '$scriptPathFromNetwork'..." -TaskId $taskId
                        
                        # Ejecutar el script
                        & $localScriptPath
                        
                        Remove-Item $localScriptPath -Force
                    }
                    "comando_powershell" {
                        Log-ToServer -Action "Ejecutando Comando" -Status "Éxito" -Message "Ejecutando: '$($taskConfig.command)'..." -TaskId $taskId
                        Invoke-Expression -Command $taskConfig.command
                    }
                }
                
                # 3. Ejecutar script post-instalación (si existe)
                if (-not [string]::IsNullOrWhiteSpace($taskConfig.postInstallScript)) {
                    Log-ToServer -Action "Post-Ejecución" -Status "Éxito" -Message "Ejecutando script post-instalación." -TaskId $taskId
                    
                    # Cambiar al directorio de instalación para que los comandos locales funcionen.
                    if ($taskConfig.installDir -and (Test-Path $taskConfig.installDir)) {
                        Set-Location -Path $taskConfig.installDir
                    }

                    Invoke-Expression -Command $taskaConfig.postInstallScript
                    
                    # Regresar al directorio original del agente
                    Set-Location -Path $PSScriptRoot
                }

            } catch {
                # --- Manejo de Errores Críticos durante la Tarea ---
                $global:taskFailed = $true
                $errorMessage = "FALLO en la tarea '$($taskConfig.name)': $($_.Exception.Message)"
                Write-Error $errorMessage
                Log-ToServer -Action "Error en Tarea" -Status "Fallo" -Message $errorMessage -TaskId $taskId
            } finally {
                # 4. Reiniciar los servicios que se detuvieron al principio
                foreach ($service in $servicesToRestart) {
                    try {
                        # SOLO reiniciar si el servicio sigue detenido.
                        $serviceObj = Get-Service -Name $service -ErrorAction SilentlyContinue
                        if ($serviceObj -and $serviceObj.Status -eq 'Stopped') {
                            Log-ToServer -Action "Reiniciando Servicio" -Status "Éxito" -Message "Reiniciando servicio '$service'..." -TaskId $taskId
                            Start-Service -Name $service
                        }
                    } catch {
                        Log-ToServer -Action "Reiniciando Servicio" -Status "Fallo" -Message "No se pudo reiniciar el servicio '$service': $($_.Exception.Message)" -TaskId $taskId
                    }
                }
                
                # 5. Reportar finalización de la tarea (solo si no hubo fallos)
                if (-not $global:taskFailed) {
                    $versionId = [System.IO.Path]::GetFileNameWithoutExtension($taskConfig.updateFilePath)
                    Log-ToServer -Action "Actualización completada" -Status "Éxito" -Message "El paquete '$($taskConfig.name)' se procesó correctamente." -VersionId $versionId -TaskId $taskId
                }
            }
        }

    } catch {
        # --- Manejo de Errores Generales del Agente ---
        $global:taskFailed = $true # Marcar que algo falló
        $errorMessage = "ERROR GENERAL DEL AGENTE: $($_.Exception.Message)"
        Write-Error $errorMessage
        Log-ToServer -Action "Error de Agente" -Status "Fallo" -Message $errorMessage
        # Esperar un tiempo prudencial antes de reintentar para no saturar el servidor en caso de un error persistente.
        Start-Sleep -Seconds 60
    }
}
