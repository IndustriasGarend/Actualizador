#Requires -RunAsAdministrator

[CmdletBinding(SupportsShouldProcess = $true)]
param()

$serviceName = "ClicActualizadorToolsAgent"
$serviceDisplayName = "Clic Actualizador Tools Agent"
$serviceDescription = "Agente de Clic Actualizador Tools que se comunica con el servidor central para ejecutar tareas de despliegue."

# La ruta al ejecutable del agente será la carpeta donde se encuentra este script.
$scriptPath = $PSScriptRoot
$agentExecutable = Join-Path -Path $scriptPath -ChildPath "agent.ps1"

# Comando que ejecutará el servicio.
# Se usa -ExecutionPolicy Bypass para asegurar que el script se ejecute sin problemas
# incluso en sistemas con políticas de ejecución restrictivas.
$serviceCommand = "powershell.exe -ExecutionPolicy Bypass -NoProfile -NoLogo -NonInteractive -File `"$agentExecutable`""

function Check-ServiceExists {
    param([string]$name)
    return Get-Service -Name $name -ErrorAction SilentlyContinue
}

# -----------------
# --- MAIN FLOW ---
# -----------------
try {
    # --- 1. Limpieza de Versiones Anteriores ---
    Write-Host "Buscando versiones anteriores del servicio..." -ForegroundColor Yellow
    if (Check-ServiceExists -name $serviceName) {
        Write-Host "Se encontró un servicio existente. Deteniendo y eliminándolo..."
        Stop-Service -Name $serviceName -Force -ErrorAction SilentlyContinue
        
        # sc.exe delete es más robusto y universal que Remove-Service
        sc.exe delete $serviceName | Out-Null
        
        Write-Host "Servicio anterior eliminado." -ForegroundColor Green
        Start-Sleep -Seconds 2 # Esperar un momento para que el SCM procese la eliminación
    } else {
        Write-Host "No se encontraron servicios anteriores."
    }

    # --- 2. Pedir URL del Servidor ---
    $configFile = Join-Path -Path $scriptPath -ChildPath "config.json"
    $serverUrl = Read-Host "`n--> Por favor, ingresa la URL del servidor (ej. http://192.168.1.100:9002)"
    $configContent = @{ serverUrl = $serverUrl } | ConvertTo-Json
    
    # Crear archivo de configuración con codificación UTF-8 sin BOM
    $utf8NoBomEncoding = New-Object System.Text.UTF8Encoding($false)
    [System.IO.File]::WriteAllLines($configFile, $configContent, $utf8NoBomEncoding)

    Write-Host "Archivo de configuracion 'config.json' creado." -ForegroundColor Green

    # --- 3. Crear el nuevo servicio ---
    Write-Host "`nCreando el nuevo servicio '$serviceName'..." -ForegroundColor Yellow
    New-Service -Name $serviceName `
                -BinaryPathName $serviceCommand `
                -DisplayName $serviceDisplayName `
                -Description $serviceDescription `
                -StartupType Automatic `
                -Credential "LocalSystem"

    Write-Host (Get-Service -Name $serviceName | Format-Table -AutoSize | Out-String)
    Write-Host "Servicio creado. Iniciando el servicio..."

    # --- 4. Iniciar el servicio ---
    Start-Service -Name $serviceName
    
    # --- 5. Mensaje de Éxito (solo si todo lo anterior funcionó) ---
    Write-Host "`n>>> ¡ÉXITO! El servicio del Agente se instaló e inició correctamente." -ForegroundColor Green
    Write-Host "Ahora debes configurar la cuenta de red para el servicio."
    Write-Host "1. Abre 'services.msc'."
    Write-Host "2. Busca el servicio '$serviceDisplayName'."
    Write-Host "3. En Propiedades > 'Iniciar sesión', cambia a 'Esta cuenta' y pon las credenciales de un usuario con acceso a la red."
    Write-Host "4. Reinicia el servicio."

}
catch {
    # --- Manejo de Errores ---
    Write-Host "`n>>> ¡ERROR!" -ForegroundColor Red
    Write-Host "Ocurrió un error durante la instalación:" -ForegroundColor Red
    Write-Host ($_.Exception.Message) -ForegroundColor Red
    
    # Salir con un código de error para que el .bat lo detecte
    exit 1
}
